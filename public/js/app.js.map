{"version":3,"sources":["routes.js","app.js","Candle.js","CandleChart.js","LineChart.js","RenkoBrick.js","Trench.js","VolumeChart.js","candleAnalysisService.js","chartService.js","indicatorService.js","opportunityService.js","strategyTestService.js","candleController.js","mainController.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACp+BA;AACA;AACA;AACA;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACznCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/jBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.js","sourcesContent":["/**\r\n * Created by Ian on 28/12/2016.\r\n */\r\nangular.module(\"stockBotRoutes\",[]).config(function($stateProvider){\r\n\r\n    //$stateProvider.state('blank', {url: \"/#\",template: \"\"}); //rota nula que não redireciona.\r\n\r\n\r\n    $stateProvider\r\n        .state('candles', {\r\n            url: \"/candles\",\r\n            //template: '<h3>hello world!</h3>'\r\n            templateUrl: \"/view/candleChart\",\r\n            controller: 'candleController'\r\n        })\r\n    ;\r\n\r\n});","/**\r\n * Created by Ian on 28/12/2016.\r\n */\r\nangular.module(\"stockBot\",[\r\n    'ui.router',\r\n    'ngMaterial',\r\n    //'nvd3',\r\n    'googlechart',\r\n    //'ngAudio',\r\n    //da app\r\n    'stockBotRoutes'\r\n\r\n]);\r\nvar app = angular.module(\"stockBot\");\r\n","/**\r\n * Created by Ian on 02/01/2017.\r\n */\r\n\r\n\r\n\r\nvar Candle = function(start,end,min,open,close,max,volume,timestamp) {\r\n    this.start = start;\r\n    this.min = min;\r\n    this.open = open;\r\n    this.close = close;\r\n    this.max = max;\r\n    this.end = end;\r\n    this.volume = volume;\r\n    this.timestamp = timestamp;\r\n};\r\n\r\nCandle.prototype.getVariation = function() {\r\n\r\n    var variation  = (Math.max(this.open,this.close) / Math.min(this.open,this.close))-1;\r\n    if(this.open > this.close) { //baixa\r\n        variation *=  -1;\r\n    }\r\n    variation *= 100;\r\n    return Math.round(variation * 1000) / 1000;\r\n    //return (variation * 100).toFixed(3);\r\n\r\n};\r\n\r\nCandle.prototype.getValorization = function(lastClosePrice) {\r\n\r\n    var variation  = (Math.max(lastClosePrice,this.close) / Math.min(lastClosePrice,this.close))-1;\r\n    if(this.open > this.close) { //baixa\r\n        variation *=  -1;\r\n    }\r\n    variation *= 100;\r\n    return Math.round(variation * 1000) / 1000;\r\n    //return (variation * 100).toFixed(3);\r\n\r\n};\r\nCandle.prototype.getDescription = function(lastClosePrice) {\r\n    return this.start+\"\\nAbe: \"+this.open+\"\\nFec: \"+this.close+\"\\nMax:\"+this.max+\"\\nMin: \"+this.min+\"\\nVol: \" + this.volume+\"\\nVariação: \"+ this.getVariation() +\"%\\nValorização: \"+ this.getValorization(lastClosePrice) +\"%\\n\"+this.end;\r\n};\r\n\r\nCandle.prototype.getBody = function() {\r\n    return Math.abs(this.open - this.close);\r\n};\r\n\r\nCandle.prototype.getUpperShadow = function() {\r\n    if(this.close >= this.open) { //candle de alta ou doji\r\n        return this.max - this.close;\r\n    }\r\n    else {\r\n        return this.max - this.open;\r\n    }\r\n};\r\n\r\nCandle.prototype.getLowerShadow = function() {\r\n    if(this.close >= this.open) { //candle de alta ou doji\r\n        return this.open - this.min;\r\n    }\r\n    else {\r\n        return this.close - this.min;\r\n    }\r\n};\r\n\r\nCandle.prototype.isBullish = function() {\r\n    return this.close >= this.open;\r\n};\r\n\r\nCandle.prototype.isBearish = function() {\r\n    return this.close < this.open;\r\n};\r\n\r\n\r\n","/**\r\n * Created by Ian on 04/01/2017.\r\n */\r\nvar CandleChart = function (candleList) {\r\n    self = this;\r\n    self.candleList = candleList;\r\n    self.type = \"LineChart\";\r\n\r\n    self.getSelection = function() {\r\n        console.log(\"vish\");\r\n    };\r\n\r\n    self.indicators = [];\r\n\r\n    self.options = {\r\n        //width: 2500,\r\n        vAxis: {\r\n            //title: \"Percentage Uptime\",\r\n            viewWindowMode:'maximized'\r\n        },\r\n        explorer: {},\r\n        crosshair: {\r\n            trigger: 'both',\r\n            //orientation: ,\r\n            opacity: 0.2\r\n        },\r\n        chartArea:{left:100,width:\"100%\"},\r\n        legend: 'none',\r\n        colors: [\"green\"],\r\n        pointSize: 1,\r\n        lineWidth: 0,\r\n        interval: {\r\n            'min' : {style: \"sticks\"},\r\n            'max' : {style: \"sticks\"},\r\n            'abe' : {style: \"boxes\"},\r\n            'fec' : {style: \"boxes\"}\r\n        }\r\n    };\r\n    self.baseOptions = angular.copy(self.options,self.baseOptions);\r\n\r\n    self.data = {\r\n        cols: [\r\n            {type: \"string\"},\r\n            {type: \"number\", role: \"data\"},\r\n            {type: \"string\", role: \"tooltip\"},\r\n            {type: \"string\", role: \"style\"},\r\n\r\n            {id: \"min\",type: \"number\", role: \"interval\"},\r\n            {id: \"abe\",type: \"number\", role: \"interval\"},\r\n            {id: \"fec\",type: \"number\", role: \"interval\"},\r\n            {id: \"max\",type: \"number\", role: \"interval\"}\r\n        ],\r\n        rows: []\r\n    };\r\n    self.baseData = angular.copy(self.data,self.baseData );\r\n\r\n    self.addIndicator = function(name,_function, style, options) {\r\n\r\n        /*\r\n         options = {\r\n         periods: number, //numero de periodos para o calculo do indicador\r\n         color: string //cor do indicador no gráfico\r\n         }\r\n         */\r\n        var indicatorName = name + \"_\" + self.indicators.length;\r\n        //console.log(indicatorName);\r\n\r\n        self.indicators.push({\r\n            name: indicatorName,\r\n            _function : _function,\r\n            style: style,\r\n            options : options\r\n        });\r\n        //console.log(self.indicators);\r\n\r\n    };\r\n\r\n    self.update = function() {\r\n\r\n        //resetando as opções\r\n        self.options = angular.copy(self.baseOptions,self.options);\r\n\r\n        //resetando os dados\r\n        self.data = angular.copy(self.baseData,self.data);\r\n\r\n        var i;\r\n        var interval_id;\r\n        var dataSize;\r\n        self.indicators.forEach(function(indicator,index) {\r\n\r\n            self.indicators[index].data = indicator._function(candleList,indicator.options.periods);\r\n            if(typeof self.indicators[index].data[0] === 'undefined')\r\n                return;\r\n\r\n            dataSize = self.indicators[index].data[0].length;\r\n\r\n            for(i = 0; i < dataSize; i++) {\r\n                interval_id = indicator.name + \"_\" + i;\r\n\r\n                self.options.interval[interval_id] = {style: indicator.style, color: indicator.options.color};\r\n                if(typeof indicator.options.pointSize !== 'undefined')\r\n                    self.options.interval[interval_id].pointSize = indicator.options.pointSize;\r\n\r\n                if(typeof indicator.options.opacity !== 'undefined')\r\n                    self.options.interval[interval_id].opacity = indicator.options.opacity;\r\n\r\n                self.options.interval[interval_id]\r\n                self.data.cols.push({\r\n                    id: interval_id,\r\n                    type: \"number\",\r\n                    role: \"interval\"\r\n                });\r\n            }\r\n        });\r\n\r\n        var  lastCandle = {\r\n            close: 0\r\n        };\r\n        var newRow;\r\n        var tempData;\r\n\r\n\r\n\r\n        self.candleList.forEach(function(candle,candleIndex){\r\n            var rtd = candle.exchange === \"RTD\" ? \" RTD \" : \"\";\r\n\r\n            newRow = {c:[\r\n                {v: \"\"},\r\n                {v: (candle.open + candle.close)/2},\r\n                {v: \"#\" + candleIndex + rtd + \"\\n\" + candle.getDescription(lastCandle.close)},\r\n                {v: candle.open >= candle.close ? \"color: red\" : \"color: green\"},\r\n\r\n                {v: candle.min}, //min\r\n                {v: candle.open}, //abertura\r\n                {v: candle.close}, //fechamento\r\n                {v: candle.max} //max\r\n            ]};\r\n\r\n            self.indicators.forEach(function(indicator) {\r\n                tempData = indicator.data[candleIndex];\r\n\r\n                tempData.forEach(function(data){\r\n                    newRow.c.push({v:data});\r\n                });\r\n            });\r\n\r\n\r\n            self.data.rows.push(newRow);\r\n            lastCandle = candle;\r\n        });\r\n\r\n        //console.log(self.options,self.data);\r\n\r\n    };\r\n};","/**\r\n * Created by Ian on 04/01/2017.\r\n */\r\nvar LineChart = function (candleList,color) {\r\n    self = this;\r\n    self.candleList = candleList;\r\n    self.type = \"LineChart\";\r\n\r\n    self.indicators = [];\r\n\r\n    self.options = {\r\n        vAxis: {\r\n            //title: \"Percentage Uptime\",\r\n            viewWindowMode:'maximized'\r\n        },\r\n        //explorer: {},\r\n        crosshair: { trigger: 'both' },\r\n        'tooltip' : {\r\n            trigger: 'hover'\r\n        },\r\n        chartArea:{left:100,width:\"100%\"},\r\n        legend: 'none',\r\n        colors: [color],\r\n        pointSize: 2,\r\n        interval: {\r\n        }\r\n    };\r\n    self.baseOptions = angular.copy(self.options,self.baseOptions);\r\n\r\n    self.data = {\r\n        cols: [\r\n            {type: \"string\"},\r\n            {type: \"number\", role: \"data\"}\r\n        ],\r\n        rows: []\r\n    };\r\n    self.baseData = angular.copy(self.data,self.baseData );\r\n\r\n    self.addIndicator = function(name,_function, style, options) {\r\n\r\n        /*\r\n         options = {\r\n         periods: number, //numero de periodos para o calculo do indicador\r\n         color: string //cor do indicador no gráfico\r\n         }\r\n         */\r\n        var indicatorName = name + \"_\" + self.indicators.length;\r\n        //console.log(indicatorName);\r\n\r\n        self.indicators.push({\r\n            name: indicatorName,\r\n            _function : _function,\r\n            style: style,\r\n            options : options\r\n        });\r\n        //console.log(self.indicators);\r\n\r\n    };\r\n\r\n    self.update = function() {\r\n\r\n        //resetando as opções\r\n        self.options = angular.copy(self.baseOptions,self.options);\r\n\r\n        //resetando os dados\r\n        self.data = angular.copy(self.baseData,self.data);\r\n\r\n        var i;\r\n        var interval_id;\r\n        var dataSize;\r\n        self.indicators.forEach(function(indicator,index) {\r\n\r\n            self.indicators[index].data = indicator._function(candleList,indicator.options.periods);\r\n            if(typeof self.indicators[index].data[0] === 'undefined')\r\n                return;\r\n\r\n            dataSize = self.indicators[index].data[0].length;\r\n\r\n            for(i = 0; i < dataSize; i++) {\r\n                interval_id = indicator.name + \"_\" + i;\r\n\r\n                self.options.interval[interval_id] = {style: indicator.style, color: indicator.options.color};\r\n                self.data.cols.push({\r\n                    id: interval_id,\r\n                    type: \"number\",\r\n                    role: \"interval\"\r\n                });\r\n            }\r\n        });\r\n\r\n        var newRow;\r\n        var tempData;\r\n        self.candleList.forEach(function(candle,candleIndex){\r\n\r\n            newRow = {c:[\r\n                {v: \"\"},\r\n                {v: candle}\r\n            ]};\r\n\r\n            self.indicators.forEach(function(indicator) {\r\n                tempData = indicator.data[candleIndex];\r\n\r\n                tempData.forEach(function(data){\r\n                    newRow.c.push({v:data});\r\n                });\r\n            });\r\n\r\n\r\n            self.data.rows.push(newRow);\r\n        });\r\n\r\n        //console.log(self.options,self.data);\r\n\r\n    };\r\n\r\n};","var RenkoBrick = function(open,close,openTime,closeTime) {\r\n    this.open = open;\r\n    this.close = close;\r\n    this.openTime = openTime;\r\n    this.closeTime = closeTime;\r\n};\r\n\r\n\r\n","/**\r\n * Created by Ian on 03/01/2017.\r\n */\r\n\r\n\r\nvar  Trench = function(value) {\r\n    this.value = value;\r\n    this.strength = 0; //confirmações.\r\n};","/**\r\n * Created by Ian on 04/01/2017.\r\n */\r\nvar VolumeChart = function (candleList) {\r\n    self = this;\r\n    self.candleList = candleList;\r\n    self.type = \"ColumnChart\";\r\n\r\n\r\n    self.indicators = [];\r\n\r\n    self.options = {\r\n        crosshair: { trigger: 'both' },\r\n        chartArea:{left:100,width:\"100%\"},\r\n        legend: 'none',\r\n        colors: [\"blue\"],\r\n        interval: {}\r\n    };\r\n    self.baseOptions = angular.copy(self.options,self.baseOptions);\r\n\r\n    self.data = {\r\n        cols: [\r\n            {type: \"string\"},\r\n            {type: \"number\", role: \"data\"},\r\n            {type: \"string\", role: \"tooltip\"}\r\n        ],\r\n        rows: []\r\n    };\r\n    self.baseData = angular.copy(self.data,self.baseData );\r\n\r\n    self.addIndicator = function(name,_function, style, options) {\r\n\r\n        /*\r\n         options = {\r\n         periods: number, //numero de periodos para o calculo do indicador\r\n         color: string //cor do indicador no gráfico\r\n         }\r\n         */\r\n        var indicatorName = name + \"_\" + self.indicators.length;\r\n        //console.log(indicatorName);\r\n\r\n        self.indicators.push({\r\n            name: indicatorName,\r\n            _function : _function,\r\n            style: style,\r\n            options : options\r\n        });\r\n        //console.log(self.indicators);\r\n\r\n    };\r\n\r\n    self.update = function() {\r\n\r\n        //resetando as opções\r\n        self.options = angular.copy(self.baseOptions,self.options);\r\n\r\n        //resetando os dados\r\n        self.data = angular.copy(self.baseData,self.data);\r\n\r\n        var i;\r\n        var interval_id;\r\n        var dataSize;\r\n        self.indicators.forEach(function(indicator,index) {\r\n\r\n            self.indicators[index].data = indicator._function(candleList,indicator.options.periods);\r\n            if(typeof self.indicators[index].data[0] === 'undefined')\r\n                return;\r\n\r\n            dataSize = self.indicators[index].data[0].length;\r\n\r\n            for(i = 0; i < dataSize; i++) {\r\n                interval_id = indicator.name + \"_\" + i;\r\n\r\n                self.options.interval[interval_id] = {style: indicator.style, color: indicator.options.color};\r\n                self.data.cols.push({\r\n                    id: interval_id,\r\n                    type: \"number\",\r\n                    role: \"interval\"\r\n                });\r\n            }\r\n        });\r\n\r\n        var newRow;\r\n        var tempData;\r\n        self.candleList.forEach(function(candle,candleIndex){\r\n\r\n            newRow = {c:[\r\n                {v: \"\"},\r\n                {v: candle.volume},\r\n                {v: candle.start + \"\\nVolume: \" + candle.volume + \"\\n\" + candle.end},\r\n            ]};\r\n\r\n            self.indicators.forEach(function(indicator) {\r\n                tempData = indicator.data[candleIndex];\r\n\r\n                tempData.forEach(function(data){\r\n                    newRow.c.push({v:data});\r\n                });\r\n            });\r\n\r\n            self.data.rows.push(newRow);\r\n        });\r\n\r\n    };\r\n\r\n};","/**\r\n * Created by Ian on 05/01/2017.\r\n */\r\napp.service(\"candleAnalysisService\",function(indicatorService) {\r\n    var self = this;\r\n\r\n\r\n\r\n    self.candlePatterns = {\r\n        //bullish\r\n        WHITE_MARUBOZU: {value: 0, name: \"WHITE_MARUBOZU\", type: 1},\r\n        PIERCING_LINE: {value: 1, name: \"PIERCING_LINE\", type: 1},\r\n        BULLISH_KICKING: {value: 2, name: \"BULLISH_KICKING\", type: 1},\r\n        BULLISH_ABANDONED_BABY: {value: 3, name: \"BULLISH_ABANDONED_BABY\", type: 1},\r\n        MORNING_STAR : {value: 4, name: \"MORNING_STAR\", type: 1},\r\n        BULLISH_ENGULFING: {value: 5, name: \"BULLISH_ENGULFING\", type: 1},\r\n        THREE_OUTSIDE_UP : {value: 6, name: \"THREE_OUTSIDE_UP\", type: 1},\r\n        BULLISH_DRAGONFLY_DOJI : {value: 7, name: \"BULLISH_DRAGONFLY_DOJI\", type: 1},\r\n        BULLISH_GRAVESTONE: {value: 8, name: \"BULLISH_GRAVESTONE\", type: 1},\r\n        BULLISH_HARAMI: {value: 9, name: \"BULLISH_HARAMI\", type: 1},\r\n        BULLISH_HARAMI_CROSS: {value: 10, name: \"BULLISH_HARAMI_CROSS\", type: 1},\r\n        BREAKWAY: {value: 11, name: \"BREAKWAY\", type: 1},\r\n        HAMMER: {value: 12, name: \"HAMMER\", type: 1}, //TODO: melhorar a formula\r\n        SHOOTING_STAR : {value: 13, name: \"SHOOTING_STAR\", type: 1},\r\n\r\n        //neutral\r\n        DOJI: {value: 100, name: \"DOJI\", type: 0},\r\n        LONG_LEGGED_DOJI : {value: 101, name: \"LONG_LEGGED_DOJI\", type: 0},\r\n\r\n        //bearish\r\n        BLACK_MARUBOZU: {value: 200, name: \"BLACK_MARUBOZU\", type: -1},\r\n        BEARISH_ABANDONED_BABY: {value: 201, name: \"BEARISH_ABANDONED_BABY\", type: -1},\r\n        BEARISH_DRAGONFLY_DOJI : {value: 202, name: \"BEARISH_DRAGONFLY_DOJI\", type: -1},\r\n        BEARISH_ENGULFING: {value: 203, name: \"BEARISH_ENGULFING\", type: -1},\r\n        DARK_CLOUD: {value: 204, name: \"DARK_CLOUD\", type: -1}, //TODO não detectou nenhum ainda pela formula nova.\r\n        EVENING_STAR : {value: 205, name: \"EVENING_STAR\", type: -1},\r\n        THREE_BLACK_CROWS : {value: 206, name: \"THREE_BLACK_CROWS\", type: -1},\r\n        BEARISH_GRAVESTONE: {value: 207, name: \"BEARISH_GRAVESTONE\", type: -1},\r\n        BEARISH_HARAMI: {value: 208, name: \"BEARISH_HARAMI\", type: -1},\r\n        BEARISH_HARAMI_CROSS: {value: 209, name: \"BEARISH_HARAMI_CROSS\", type: -1},\r\n        BEARISH_KICKING: {value: 210, name: \"BEARISH_KICKING\", type: -1},\r\n        HANGING_MAN: {value: 211, name: \"HANGING_MAN\", type: -1},  //TODO: melhorar a formula\r\n        INVERTED_HAMMER: {value: 12, name: \"INVERTED_HAMMER\", type: -1},\r\n\r\n        //auxiliar em teste\r\n        LONG_BODY: {value: 400, name: \"LONG_BODY\"},\r\n        LONG_LEGS: {value: 401, name: \"LONG_LEGS\"},\r\n        SHORT_BODY: {value: 402, name: \"SHORT_BODY\"},\r\n        LONG_SHADOW_LOWER : {value: 403, name: \"LONG_SHADOW_LOWER\"},\r\n        LONG_SHADOW_UPPER : {value: 404, name: \"LONG_SHADOW_UPPER\"}\r\n\r\n        //auxiliares\r\n        //valor >= 500 indica q é auxiliar, e não deve ser detectado em detectAll;\r\n\r\n\r\n\r\n    };\r\n\r\n\r\n    //TODO: DIFERENCIAR TENDENCIA DE MOVIMENTOS.\r\n    //Parece que nos exemplos de padrões, os traços anteriores/posteriores são movimentos, e não tendências.\r\n\r\n    self.detect = function(pattern,candleList) {\r\n\r\n        if(candleList.length === 0) //n tem candle pra detectar\r\n            return false;\r\n\r\n\r\n        //padrão não definido.\r\n        if(typeof self.candlePatterns[pattern.name] === 'undefined') {\r\n            console.log(\"padrão inválido\");\r\n            return false;\r\n        }\r\n\r\n        var _function = \"detect_\" + pattern.name;\r\n        //função de detecção não implementada\r\n        if(typeof self[_function] === 'undefined') {\r\n            console.log(\"função de detecção não implementada\");\r\n            return false;\r\n        }\r\n\r\n        return self[_function](candleList);\r\n    };\r\n    self.detectAll = function(candleList) {\r\n\r\n        var patternList = [];\r\n        var results = []\r\n\r\n        //convertendo para array a lista de padrões;\r\n        for (var key in self.candlePatterns)\r\n            patternList.push(self.candlePatterns[key]);\r\n\r\n        patternList.forEach(function(pattern){\r\n            //valor >= 500 indica q é auxiliar, e não deve ser detectado em detectAll;\r\n            if(pattern.value >= 500)\r\n                return;\r\n\r\n            if(candleList.length === 0) { //n tem candle pra detectar\r\n                results.push([pattern.value,pattern.name,false]);\r\n                return;\r\n            }\r\n\r\n            var _function = \"detect_\" + pattern.name;\r\n            //função de detecção não implementada\r\n            if(typeof self[_function] === 'undefined') {\r\n                results.push([pattern.value,pattern.name,false]);\r\n                return;\r\n            }\r\n\r\n            results.push([pattern.value,pattern.name,self[_function](candleList)]);\r\n        });\r\n\r\n\r\n        return results;\r\n\r\n    };\r\n\r\n    //detectores bullish\r\n    self.detect_WHITE_MARUBOZU = function(candleList) {\r\n\r\n        var candle = candleList[candleList.length -1];\r\n\r\n        if(!candle.isBullish()) //não é de alta.\r\n            return false;\r\n\r\n        //corpo longo\r\n        if(self.detect_LONG_BODY(candleList))\r\n            return false; //corpo curto\r\n\r\n\r\n        //soma das sombras = 0\r\n        if((candle.getUpperShadow() + candle.getLowerShadow()) > 0)\r\n            return false; //soma das sombras maior que 0\r\n\r\n        return true;\r\n    };\r\n    self.detect_PIERCING_LINE = function(candleList) {\r\n\r\n        var size = candleList.length;\r\n\r\n        if(size < 2) //tamanho insuficiente pra detectar.\r\n            return false;\r\n\r\n\r\n\r\n        //formula de teste\r\n\r\n        candle1 = candleList[size-2];\r\n        candle = candleList[size-1];\r\n\r\n        return  (candle1.close < candle1.open) &&\r\n                (((candle1.open + candle1.close) / 2) < candle.close) &&\r\n                (candle.open < candle.close) && (candle.open < candle1.close) &&\r\n                (candle.close < candle1.open) &&\r\n                ((candle.close - candle.open) / (0.001 + (candle.max - candle.min)) > 0.6)\r\n        ;\r\n\r\n\r\n\r\n        //tendencia atual: baixa\r\n        var tendency = indicatorService.getActualTendency(candleList);\r\n        //console.log(tendency.type !== indicatorService.tendencyType.BEARISH,\":\",tendency);\r\n        if(tendency.type !== indicatorService.tendencyType.BEARISH)\r\n            return false; //tendencia não é de baixa.\r\n\r\n        //candle anterior: baixa\r\n        if(!candleList[size-2].isBearish())\r\n            return false; //candle anterior não é de baixa.\r\n\r\n        //candle atual: alta\r\n        if(!candleList[size-1].isBullish())\r\n            return false; //candle atual não é de alta.\r\n\r\n        //candle atual tem corpo longo.\r\n        if(!self.detect_LONG_BODY([candleList[size-1]]))\r\n            return false; //candle atual não tem corpo longo.\r\n\r\n\r\n\r\n        //caracteristica do atual: fechamento superior a metade do corpo do anterior.\r\n        var middle = candleList[size-2].open - (candleList[size-2].getBody()/2);\r\n        return candleList[size-1].close > middle;\r\n\r\n    };\r\n    self.detect_BULLISH_KICKING = function(candleList) {\r\n        var size = candleList.length;\r\n\r\n        if(size < 2) //tamanho insuficiente pra detectar.\r\n            return false;\r\n\r\n\r\n        //formula de teste\r\n        candle1 = candleList[size-2];\r\n        candle = candleList[size-1];\r\n\r\n        return  (candle1.open > candle1.close) && \r\n                (candle.open >= candle1.open) && \r\n                (candle.close > candle.open)\r\n        ;\r\n\r\n\r\n        var list = [];\r\n\r\n        list.push(candleList[size-2]);\r\n        var black_marubozu = self.detect_BLACK_MARUBOZU(list);\r\n        if(!black_marubozu) //esse n é o penultimo.\r\n            return false;\r\n\r\n        list.push(candleList[size-1]);\r\n        var white_marubozu = self.detect_WHITE_MARUBOZU(list);\r\n        if(!white_marubozu) //esse n é o ultimo\r\n            return false;\r\n\r\n        //houve formação de gap entre os dois?\r\n        return list[0].open < list[1].open;\r\n    };\r\n    self.detect_DOJI = function(candleList){\r\n\r\n\r\n\r\n        var dojiDetectionFactor = 0.02;//porcentagem de variação do corpo máxima para detecção\r\n        candle = candleList[candleList.length-1];\r\n\r\n        //formula de teste\r\n        return (Math.abs(candle.open - candle.close) <= ((candle.max - candle.min ) * 0.1));\r\n\r\n\r\n\r\n\r\n        //variação entre abertura e fechamento;\r\n        var variation  = (Math.max(candle.open,candle.close) / Math.min(candle.open,candle.close))-1;\r\n        variation *= 100;\r\n\r\n        //variação menor ou igual  a permitida.\r\n        return variation <= dojiDetectionFactor\r\n    };\r\n    self.detect_LONG_LEGGED_DOJI = function(candleList){\r\n\r\n\r\n        return self.detect_DOJI(candleList) && self.detect_LONG_LEGS(candleList);\r\n\r\n    };\r\n    self.detect_BULLISH_ABANDONED_BABY = function(candleList) {\r\n\r\n        var size = candleList.length;\r\n\r\n        if(size < 3) //tamanho insuficiente pra detectar.\r\n            return false;\r\n\r\n        //tendencia atual: baixa\r\n        var tendency = indicatorService.getActualTendency(candleList);\r\n        if(tendency.type !== indicatorService.tendencyType.BEARISH)\r\n            return false; //tendencia não é de baixa.\r\n\r\n        //primeiro: baixa e não doji.\r\n        if(!candleList[size-3].isBearish() || self.detect_DOJI([candleList[size-3]]))\r\n            return false; //não é de baixa ou é doji\r\n\r\n\r\n        //segundo: doji\r\n        if(!self.detect_DOJI([candleList[size-2]]))\r\n            return false; //não é doji\r\n\r\n        //terceiro: alta e não doji.\r\n        if(!candleList[size-1].isBullish() || self.detect_DOJI([candleList[size-1]]))\r\n            return false; //não é de alta ou é doji\r\n\r\n        //gap entre a máxima do doji e minima dos candles em volta.\r\n        return candleList[size-2].max < candleList[size-3].min && candleList[size-2].max < candleList[size-1].min;\r\n\r\n    };\r\n    self.detect_MORNING_STAR = function(candleList) {\r\n\r\n\r\n        //TODO: os candles de corpo pequeno entre os dois maiores podem ser mais de um.\r\n        var size = candleList.length;\r\n\r\n        if(size < 3) //tamanho insuficiente pra detectar.\r\n            return false;\r\n\r\n        //formula de teste\r\n        candle2 = candleList[size-3];\r\n        candle1 = candleList[size-2];\r\n        candle = candleList[size-1];\r\n\r\n\r\n        return  (candle2.open>candle2.close)&&\r\n                ((candle2.open-candle2.close)/(0.001+candle2.max-candle2.min)>0.6)&&\r\n                (candle2.close>candle1.open)&&\r\n                (candle1.open>candle1.close)&&\r\n                ((candle1.max-candle1.min)>(3*(candle1.close-candle1.open)))&&\r\n                (candle.close>candle.open)&&\r\n                (candle.open>candle1.open)\r\n        ;\r\n\r\n\r\n\r\n\r\n        //tendencia atual: baixa\r\n        var tendency = indicatorService.getActualTendency(candleList);\r\n        if(tendency.type !== indicatorService.tendencyType.BEARISH)\r\n            return false; //tendencia não é de baixa.\r\n\r\n        //primeiro: baixa e não doji.\r\n        if(!candleList[size-3].isBearish() || self.detect_DOJI([candleList[size-3]]))\r\n            return false; //não é de baixa ou é doji\r\n\r\n\r\n        //segundo: corpo curto ou doji\r\n        if(!self.detect_SHORT_BODY([candleList[size-2]]))\r\n            return false; //corpo não é curto\r\n\r\n\r\n        //terceiro: alta e não doji.\r\n        if(!candleList[size-1].isBullish() || self.detect_DOJI([candleList[size-1]]))\r\n            return false; //não é de alta ou é doji\r\n\r\n        return true;\r\n    };\r\n    self.detect_SHOOTING_STAR = function(candleList) {\r\n\r\n        candle = candleList[candleList.length-1];\r\n\r\n        return  ((candle.max - candle.min) > 4 * (candle.open - candle.close)) &&\r\n                ((candle.max - candle.close) / (0.001 + candle.max - candle.min) >= 0.75) &&\r\n                ((candle.max - candle.open) / (0.001 + candle.max - candle.min) >= 0.75)\r\n        ;\r\n\r\n\r\n\r\n\r\n    };\r\n    self.detect_BULLISH_ENGULFING = function(candleList) {\r\n        var size = candleList.length;\r\n\r\n        if(size < 2) //tamanho insuficiente pra detectar.\r\n            return false;\r\n\r\n\r\n\r\n\r\n        //formula de teste\r\n\r\n        candle1 = candleList[size-2];\r\n        candle = candleList[size-1];\r\n\r\n        return  (candle1.open > candle1.close) &&\r\n                (candle.close > candle.open) &&\r\n                (candle.close >= candle1.open) &&\r\n                (candle1.close >= candle.open) &&\r\n                ((candle.close - candle.open) > (candle1.open - candle1.close))\r\n        ;\r\n\r\n\r\n\r\n\r\n\r\n        //tendencia atual: baixa\r\n        var tendency = indicatorService.getActualTendency(candleList);\r\n        if(tendency.type !== indicatorService.tendencyType.BEARISH)\r\n            return false; //tendencia não é de baixa.\r\n\r\n        //primeiro: baixa (calibrar pra ver se pode ou não ser doji).\r\n        if(!candleList[size-2].isBearish() || self.detect_DOJI([candleList[size-2]]))\r\n            return false; //não é de baixa ou é doji\r\n\r\n        //segundo: alta (calibrar pra ver se corpo longo ou não)\r\n        if(!candleList[size-1].isBullish() || !self.detect_LONG_BODY([candleList[size-1]]))\r\n            return false; //não é de alta ou não tem corpo longo\r\n\r\n        //corpo do segundo encobre o corpo do primeiro (não tem necessidade de encobrir as sombras)\r\n        return candleList[size-1].close > candleList[size-2].open &&  candleList[size-1].open < candleList[size-2].close;\r\n\r\n    };\r\n    self.detect_THREE_OUTSIDE_UP = function(candleList) {\r\n        var size = candleList.length;\r\n\r\n        if(size < 3) //tamanho insuficiente pra detectar.\r\n            return false;\r\n\r\n        //engolfo de alta\r\n        if(!self.detect_BULLISH_ENGULFING([candleList[size-3],candleList[size-2]]))\r\n            return false; //não contem engolfo de alta anterior.\r\n\r\n        //confirmação de alta (calibrar pra ver se precisa de corpo longo)\r\n        if(!candleList[size-1].isBullish() || !self.detect_LONG_BODY([candleList[size-1]]))\r\n            return false; //não é de alta ou não tem corpo longo\r\n\r\n        return true;\r\n    };\r\n    self.detect_BULLISH_DRAGONFLY_DOJI = function(candleList){\r\n        var candle = candleList[candleList.length-1];\r\n\r\n        //tendencia atual: baixa\r\n        var tendency = indicatorService.getActualTendency(candleList);\r\n        if(tendency.type !== indicatorService.tendencyType.BEARISH)\r\n            return false; //tendencia não é de baixa.\r\n\r\n       //é doji\r\n        if(!self.detect_DOJI([candle]))\r\n            return false; //não é doji.\r\n\r\n        //sombra superior bem curta. 10% da inferior ou menos\r\n        if(candle.getUpperShadow() > (candle.getLowerShadow() * 0.1))\r\n            return false; //não é curta a sombra superior.\r\n\r\n        //longa sombra inferior. variação de 0.1% no preço. de abertura/fechamento/maximo\r\n        return candle.min <= (candle.close * 0.999);\r\n\r\n    };\r\n    self.detect_BULLISH_GRAVESTONE = function(candleList){\r\n        var size = candleList.length;\r\n\r\n        if(size < 2) //tamanho insuficiente pra detectar.\r\n            return false;\r\n\r\n        //tendencia atual: baixa\r\n        var tendency = indicatorService.getActualTendency(candleList);\r\n        if(tendency.type !== indicatorService.tendencyType.BEARISH)\r\n            return false; //tendencia não é de baixa.\r\n\r\n        //primeiro: baixa e não doji.\r\n        if(!candleList[size-2].isBearish() || self.detect_DOJI([candleList[size-2]]))\r\n            return false; //não é de baixa ou é doji\r\n\r\n        //segundo: doji q encerra na minima.\r\n        if(!self.detect_DOJI([candleList[size-1]]) || candleList[size-2].close !== candleList[size-1].min)\r\n            return false; //não é doji ou não encerrou na minima\r\n\r\n        return true;\r\n    };\r\n    self.detect_BULLISH_HARAMI = function(candleList){\r\n        var size = candleList.length;\r\n\r\n        if(size < 2) //tamanho insuficiente pra detectar.\r\n            return false;\r\n\r\n        candle1 = candleList[size-2];\r\n        candle = candleList[size-1];\r\n\r\n        return  (candle1.open > candle1.close) &&\r\n                (candle.close > candle.open) &&\r\n                (candle.close <= candle1.open) &&\r\n                (candle1.close <= candle.open) &&\r\n                ((candle.close - candle.open) < (candle1.open - candle1.close))\r\n            ;\r\n    };\r\n    self.detect_BULLISH_HARAMI_CROSS = function(candleList){\r\n        var size = candleList.length;\r\n\r\n        if(size < 2) //tamanho insuficiente pra detectar.\r\n            return false;\r\n\r\n        //tendencia atual: baixa\r\n        var tendency = indicatorService.getActualTendency(candleList);\r\n        if(tendency.type !== indicatorService.tendencyType.BEARISH)\r\n            return false; //tendencia não é de baixa.\r\n\r\n\r\n        //primeiro: candle força baixa. (calibrar pra ver se eh marubozu ou soh longo msm)\r\n        if(!self.detect_LONG_BODY([candleList[size-2]]) || !candleList[size-2].isBearish())\r\n            return false; //não é longo ou de baixa.\r\n\r\n        //segundo: doji.\r\n        if(!self.detect_DOJI([candleList[size-2]]))\r\n            return false; //não é doji\r\n\r\n        return true;\r\n    };\r\n    self.detect_BREAKWAY = function(candleList){\r\n\r\n\r\n        //TODO: complexo. procurar por mais fontes de definição do padrão.\r\n        return false;\r\n\r\n        var size = candleList.length;\r\n\r\n        if(size < 5) //tamanho insuficiente pra detectar.\r\n            return false;\r\n\r\n        //tendencia atual: baixa\r\n        var tendency = indicatorService.getActualTendency(candleList);\r\n        if(tendency.type !== indicatorService.tendencyType.BEARISH)\r\n            return false; //tendencia não é de baixa.\r\n\r\n        //TODO: CONTINUAR DETECÇÃO\r\n        //primeiro: baixa forte, longo\r\n        //segundo: baixa\r\n\r\n        //quinto: alta\r\n\r\n\r\n        return true;\r\n    };\r\n    self.detect_HAMMER = function(candleList){\r\n        candle = candleList[candleList.length-1];\r\n\r\n        return  ((candle.max-candle.min)>3*(candle.open-candle.close)&&\r\n                ((candle.close-candle.min)/(0.001+candle.max-candle.min)>0.6)&&\r\n                ((candle.open-candle.min)/(0.001+candle.max-candle.min)>0.6))\r\n        ;\r\n    };\r\n\r\n    //detectores bearish\r\n    self.detect_DARK_CLOUD = function(candleList) {\r\n\r\n        var size = candleList.length;\r\n\r\n        if(size < 2) //tamanho insuficiente pra detectar.\r\n            return false;\r\n\r\n        candle1 = candleList[size-2];\r\n        candle = candleList[size-1];\r\n\r\n        return  (candle1.close > candle1.open) &&\r\n                (((candle.close1 + candle1.open) / 2) > candle.close) &&\r\n                (candle.open > candle.close) && (candle.open > candle.close1) &&\r\n                (candle.close > candle1.open) &&\r\n                ((candle.open - candle.close) / (0.001 + (candle.max - candle.min)) > 0.6)\r\n        ;\r\n\r\n\r\n        //tendencia atual: alta\r\n        var tendency = indicatorService.getActualTendency(candleList);\r\n        //console.log(tendency.type !== indicatorService.tendencyType.BEARISH,\":\",tendency);\r\n        if(tendency.type !== indicatorService.tendencyType.BULLISH)\r\n            return false; //tendencia não é de alta.\r\n\r\n        //candle anterior: alta\r\n        if(!candleList[size-2].isBullish())\r\n            return false; //candle anterior não é de alta.\r\n\r\n        //candle atual: baixa\r\n        if(!candleList[size-1].isBearish())\r\n            return false; //candle atual não é de baixa.\r\n\r\n        //candle atual tem corpo longo.\r\n        if(!self.detect_LONG_BODY([candleList[size-1]]))\r\n            return false; //candle atual não tem corpo longo.\r\n\r\n\r\n        //candle atual tem abertura maior que máxima do candle anterior.\r\n        if(candleList[size-1].open < candleList[size-2].max)\r\n            return false;// abertura não é maior que máxima do anterior.\r\n\r\n\r\n\r\n        //caracteristica do atual: fechamento inferior a metade do corpo do anterior.\r\n        var middle = candleList[size-2].open + (candleList[size-2].getBody()/2);\r\n        return candleList[size-1].close < middle;\r\n\r\n    };\r\n    self.detect_BEARISH_ABANDONED_BABY = function(candleList) {\r\n        var size = candleList.length;\r\n\r\n        if(size < 3) //tamanho insuficiente pra detectar.\r\n            return false;\r\n\r\n        //tendencia atual: alta\r\n        var tendency = indicatorService.getActualTendency(candleList);\r\n        if(tendency.type !== indicatorService.tendencyType.BULLISH)\r\n            return false; //tendencia não é de alta.\r\n\r\n        //primeiro: alta e não doji\r\n        if(!candleList[size-3].isBullish()|| self.detect_DOJI([candleList[size-3]]))\r\n            return false; //não é de alta ou é doji\r\n\r\n        //segundo: doji\r\n        if(!self.detect_DOJI([candleList[size-2]]))\r\n            return false; //não é doji\r\n\r\n        //terceiro: baixa e não doji\r\n        if(!candleList[size-1].isBearish()|| self.detect_DOJI([candleList[size-1]]))\r\n            return false; //não é de baixa ou é doji\r\n\r\n        //gap entre a minima do doji e máxima dos candles em volta.\r\n        return candleList[size-2].min > candleList[size-3].max && candleList[size-2].min > candleList[size-1].max;\r\n\r\n    };\r\n    self.detect_BLACK_MARUBOZU = function(candleList) {\r\n\r\n        var candle = candleList[candleList.length -1];\r\n\r\n        if(!candle.isBearish()) //não é de baixa.\r\n            return false;\r\n\r\n        //corpo longo\r\n        if(self.detect_LONG_BODY(candleList))\r\n            return false; //corpo curto\r\n\r\n        //soma das sombras = 0\r\n        if((candle.getUpperShadow() + candle.getLowerShadow()) > 0)\r\n            return false; //soma das sombras maior que 0\r\n\r\n        return true;\r\n    };\r\n    self.detect_EVENING_STAR = function(candleList) {\r\n\r\n\r\n        //TODO: os candles de corpo pequeno entre os dois maiores podem ser mais de um.\r\n        var size = candleList.length;\r\n\r\n        if(size < 3) //tamanho insuficiente pra detectar.\r\n            return false;\r\n\r\n\r\n\r\n        //formula de teste\r\n        candle2 = candleList[size-3];\r\n        candle1 = candleList[size-2];\r\n        candle = candleList[size-1];\r\n\r\n\r\n        return  (candle2.close > candle2.open) &&\r\n                ((candle2.close - candle2.open) / (0.001 + candle2.max - candle2.min) > 0.6) &&\r\n                (candle2.close < candle1.open) && (candle1.close > candle1.open) &&\r\n                ((candle1.max - candle1.min) > (3 * (candle1.close - candle1.open))) &&\r\n                (candle.open > candle.close) && (candle.open < candle1.open)\r\n        ;\r\n\r\n\r\n\r\n        //tendencia atual: alta\r\n        var tendency = indicatorService.getActualTendency(candleList);\r\n        if(tendency.type !== indicatorService.tendencyType.BULLISH)\r\n            return false; //tendencia não é de alta.\r\n\r\n        //primeiro: alta e não doji.\r\n        if(!candleList[size-3].isBullish() || self.detect_DOJI([candleList[size-3]]))\r\n            return false; //não é de alta ou é doji\r\n\r\n\r\n        //segundo: corpo curto ou doji\r\n        if(!self.detect_SHORT_BODY([candleList[size-2]]))\r\n            return false; //corpo não é curto\r\n\r\n        //terceiro: baixa e não doji.\r\n        if(!candleList[size-1].isBearish() || self.detect_DOJI([candleList[size-1]]))\r\n            return false; //não é de baixa ou é doji\r\n\r\n        return true;\r\n    };\r\n    self.detect_THREE_BLACK_CROWS = function(candleList) {\r\n\r\n\r\n\r\n        var size = candleList.length;\r\n\r\n        if(size < 3) //tamanho insuficiente pra detectar.\r\n            return false;\r\n\r\n        //tendencia atual: alta\r\n        var tendency = indicatorService.getActualTendency(candleList);\r\n        if(tendency.type !== indicatorService.tendencyType.BULLISH)\r\n            return false; //tendencia não é de alta.\r\n\r\n        for(var i = 1; i <= 3; i++) {\r\n            //todos lognos e de baixa.\r\n            if (!candleList[size-i].isBearish() || self.detect_LONG_BODY([candleList[size-i]]))\r\n                return false;\r\n        }\r\n\r\n\r\n        return true;\r\n    };\r\n    self.detect_BEARISH_DRAGONFLY_DOJI = function(candleList){\r\n        var candle = candleList[candleList.length-1];\r\n\r\n        //tendencia atual: alta\r\n        var tendency = indicatorService.getActualTendency(candleList);\r\n        if(tendency.type !== indicatorService.tendencyType.BULLISH)\r\n            return false; //tendencia não é de alta.\r\n\r\n        //é doji\r\n        if(!self.detect_DOJI([candle]))\r\n            return false; //não é doji.\r\n\r\n        //sombra superior bem curta. 10% da inferior ou menos\r\n        if(candle.getUpperShadow() > (candle.getLowerShadow() * 0.1))\r\n            return false; //não é curta a sombra superior.\r\n\r\n        //longa sombra inferior. variação de 0.1% no preço. de abertura/fechamento/maximo\r\n        return candle.min <= (candle.close * 0.999);\r\n\r\n    };\r\n    self.detect_BEARISH_ENGULFING = function(candleList) {\r\n        var size = candleList.length;\r\n\r\n        if(size < 2) //tamanho insuficiente pra detectar.\r\n            return false;\r\n\r\n\r\n        //formula de teste.\r\n        candle1 = candleList[size-2];\r\n        candle = candleList[size-1];\r\n\r\n        return  (candle1.close > candle1.open) &&\r\n                (candle.open > candle.close) &&\r\n                (candle.open >= candle1.close) &&\r\n                (candle1.open >= candle.close) &&\r\n                ((candle.open - candle.close) > (candle1.close - candle1.open))\r\n        ;\r\n\r\n\r\n\r\n\r\n\r\n        //tendencia atual: alta\r\n        var tendency = indicatorService.getActualTendency(candleList);\r\n        if(tendency.type !== indicatorService.tendencyType.BULLISH)\r\n            return false; //tendencia não é de alta.\r\n\r\n        //primeiro: alta (calibrar pra ver se pode ou não ser doji).\r\n        if(!candleList[size-2].isBullish() || self.detect_DOJI([candleList[size-2]]))\r\n            return false; //não é de alta ou é doji\r\n\r\n        //segundo: baixa(calibrar pra ver se corpo longo ou não)\r\n        if(!candleList[size-1].isBearish() || !self.detect_LONG_BODY([candleList[size-1]]))\r\n            return false; //não é de baixa ou não tem corpo longo\r\n\r\n        //corpo do segundo encobre o corpo do primeiro (não tem necessidade de encobrir as sombras)\r\n        return candleList[size-1].close < candleList[size-2].open &&  candleList[size-1].open > candleList[size-2].close;\r\n\r\n    };\r\n    self.detect_BEARISH_GRAVESTONE = function(candleList){\r\n        var size = candleList.length;\r\n\r\n        if(size < 2) //tamanho insuficiente pra detectar.\r\n            return false;\r\n\r\n        //tendencia atual: alta\r\n        var tendency = indicatorService.getActualTendency(candleList);\r\n        if(tendency.type !== indicatorService.tendencyType.BULLISH)\r\n            return false; //tendencia não é de alta.\r\n\r\n        //primeiro: alta e não doji.\r\n        if(!candleList[size-2].isBullish() || self.detect_DOJI([candleList[size-2]]))\r\n            return false; //não é de alta ou é doji\r\n\r\n        //segundo: doji q encerra na minima.\r\n        if(!self.detect_DOJI([candleList[size-1]]) || candleList[size-2].close !== candleList[size-1].min)\r\n            return false; //não é doji ou não encerrou na minima\r\n\r\n        return true;\r\n    };\r\n    self.detect_BEARISH_HARAMI = function(candleList){\r\n        var size = candleList.length;\r\n\r\n        if(size < 2) //tamanho insuficiente pra detectar.\r\n            return false;\r\n\r\n        candle1 = candleList[size-2];\r\n        candle = candleList[size-1];\r\n\r\n\r\n        return  (candle1.close > candle1.open) &&\r\n                (candle.open > candle.close) &&\r\n                (candle.open <= candle1.close) &&\r\n                (candle1.open <= candle.close) &&\r\n                ((candle.open - candle.close) < (candle1.close - candle1.open))\r\n            ;\r\n    };\r\n    self.detect_BEARISH_HARAMI_CROSS = function(candleList){\r\n        var size = candleList.length;\r\n\r\n        if(size < 2) //tamanho insuficiente pra detectar.\r\n            return false;\r\n\r\n        //tendencia atual: alta\r\n        var tendency = indicatorService.getActualTendency(candleList);\r\n        if(tendency.type !== indicatorService.tendencyType.BULLISH)\r\n            return false; //tendencia não é de alta.\r\n\r\n\r\n        //primeiro: candle força de alta. (calibrar pra ver se eh marubozu ou soh longo msm)\r\n        if(!self.detect_LONG_BODY([candleList[size-2]]) || !candleList[size-2].isBullish())\r\n            return false; //não é longo ou de alta.\r\n\r\n        //segundo: doji.\r\n        if(!self.detect_DOJI([candleList[size-2]]))\r\n            return false; //não é doji\r\n\r\n        return true;\r\n    };\r\n    self.detect_BEARISH_KICKING = function(candleList) {\r\n        var size = candleList.length;\r\n\r\n        if(size < 2) //tamanho insuficiente pra detectar.\r\n            return false;\r\n\r\n\r\n        //formula de teste\r\n        candle1 = candleList[size-2];\r\n        candle = candleList[size-1];\r\n\r\n        return  (candle1.open < candle1.close) &&\r\n            (candle.open <= candle1.open) &&\r\n            (candle.close <= candle.open)\r\n            ;\r\n    };\r\n    self.detect_HANGING_MAN = function(candleList){\r\n        candle = candleList[candleList.length-1];\r\n\r\n        return  (((candle.max - candle.min) > 4 * (candle.open - candle.close)) &&\r\n                ((candle.close - candle.min) / (0.001 + candle.max - candle.min) >= 0.75) &&\r\n                ((candle.open - candle.min) / (0.001 + candle.max - candle.min) >= 0.075))\r\n        ;\r\n\r\n    };\r\n    self.detect_INVERTED_HAMMER = function(candleList){\r\n        candle = candleList[candleList.length-1];\r\n\r\n        return  ((candle.max - candle.min) > 3 * (candle.open - candle.close)) &&\r\n                ((candle.max - candle.close) / (0.001 + candle.max - candle.min) > 0.6) &&\r\n                ((candle.max - candle.open) / (0.001 + candle.max - candle.min) > 0.6)\r\n        ;\r\n\r\n\r\n    };\r\n\r\n\r\n\r\n\r\n\r\n    //detectores auxiliares\r\n    self.detect_LONG_BODY = function(candleList) {\r\n\r\n        var mmeLife = 8;\r\n        var detectionFactor = 1.5;\r\n\r\n        if(candleList.size < mmeLife ) {\r\n            return false; //insuficiente pra calcular a média do corpo.\r\n        }\r\n\r\n        //o tamanho da parte é 1.5x maior que a MMEB5.\r\n\r\n\r\n        var mme = indicatorService.MMEB(candleList, mmeLife ).pop().pop();\r\n\r\n        if(mme === null)\r\n            return false;\r\n\r\n        var candle = candleList[candleList.length - 1];\r\n\r\n        //console.log(candle.getBody(),mme,candle.getBody()/mme);\r\n        return (candle.getBody() / mme) > detectionFactor;\r\n\r\n\r\n\r\n\r\n        //o corpo é maior do que a soma das sombras.\r\n        var candle = candleList[candleList.length - 1];\r\n\r\n        return candle.getBody() > (candle.getUpperShadow() + candle.getLowerShadow());\r\n\r\n        //testar depois com o resto.\r\n\r\n        if (candle.getBody() < (candle.getUpperShadow() + candle.getLowerShadow())) {\r\n            return false; //corpo menor que soma das sombras.\r\n        }\r\n\r\n        return candle.getBody() > indicatorService.MMEB(candleList,4)[candleList.length-1][0];\r\n\r\n    };\r\n    self.detect_SHORT_BODY = function(candleList) {\r\n\r\n\r\n\r\n\r\n        var mmeLife = 8;\r\n        var detectionFactor = 1.5;\r\n\r\n        if(candleList.size < mmeLife ) {\r\n            return false; //insuficiente pra calcular a média do corpo.\r\n        }\r\n\r\n        //o tamanho da parte é 1.5x maior que a MMEB5.\r\n\r\n\r\n        var mme = indicatorService.MMEB(candleList, mmeLife ).pop().pop();\r\n\r\n        if(mme === null)\r\n            return false;\r\n\r\n        var candle = candleList[candleList.length - 1];\r\n\r\n        if(candle.getBody() == 0 )\r\n            return true;\r\n\r\n\r\n        return ( mme / candle.getBody()) > detectionFactor;\r\n\r\n\r\n\r\n\r\n\r\n\r\n        var candle = candleList[candleList.length-1];\r\n\r\n        //a variação do corpo é de no máximo 0.07%\r\n        return Math.abs( (Math.max(candle.open,candle.close) / Math.min(candle.open,candle.close))-1) < 0.0007;\r\n\r\n    };\r\n    self.detect_LONG_LEGS = function(candleList) {\r\n        return self.detect_LONG_SHADOW_LOWER(candleList) && self.detect_LONG_SHADOW_UPPER(candleList);\r\n    };\r\n    self.detect_LONG_SHADOW_LOWER = function(candleList) {\r\n\r\n        var mmeLife = 8;\r\n        var detectionFactor = 1.5;\r\n\r\n        if(candleList.size < mmeLife ) {\r\n            return false; //insuficiente pra calcular a média do corpo.\r\n        }\r\n\r\n        //o tamanho da parte é 1.5x maior que a MMEB5.\r\n\r\n\r\n        var mme = indicatorService.MMELS(candleList, mmeLife ).pop().pop();\r\n\r\n        if(mme === null)\r\n            return false;\r\n\r\n        var candle = candleList[candleList.length - 1];\r\n\r\n        //console.log(candle.getLowerShadow(),mme,candle.getLowerShadow()/mme);\r\n        return (candle.getLowerShadow() / mme) > detectionFactor;\r\n    };\r\n    self.detect_LONG_SHADOW_UPPER = function(candleList) {\r\n\r\n        var mmeLife = 8;\r\n        var detectionFactor = 1.5;\r\n\r\n        if(candleList.size < mmeLife ) {\r\n            return false; //insuficiente pra calcular a média do corpo.\r\n        }\r\n\r\n        //o tamanho da parte é 1.5x maior que a MME(mmeLife).\r\n\r\n\r\n        var mme = indicatorService.MMEUS(candleList, mmeLife ).pop().pop();\r\n\r\n        if(mme === null)\r\n            return false;\r\n\r\n        var candle = candleList[candleList.length - 1];\r\n\r\n        //console.log(candle.getLowerShadow(),mme,candle.getLowerShadow()/mme);\r\n        return (candle.getUpperShadow() / mme) > detectionFactor;\r\n    };\r\n    self.detect_SHORT_SHADOW_LOWER = function(candleList) {\r\n\r\n\r\n        var candle = candleList[candleList.length - 1];\r\n        if(candle.getLowerShadow() == 0 )\r\n            return true;\r\n\r\n        var mmeLife = 8;\r\n        var detectionFactor = 1.5;\r\n\r\n        if(candleList.size < mmeLife ) {\r\n            return false; //insuficiente pra calcular a média do corpo.\r\n        }\r\n\r\n        //o tamanho da parte é 1.5x maior que a MME(mmeLife).\r\n        var mme = indicatorService.MMEUS(candleList, mmeLife ).pop().pop();\r\n\r\n        if(mme === null)\r\n            return false;\r\n\r\n        //console.log(candle.getLowerShadow(),mme,candle.getLowerShadow()/mme);\r\n        return ( mme / candle.getLowerShadow()) > detectionFactor;\r\n    };\r\n    self.detect_SHORT_SHADOW_UPPER = function(candleList) {\r\n\r\n        var candle = candleList[candleList.length - 1];\r\n        if(candle.getUpperShadow() == 0 )\r\n            return true;\r\n\r\n        var mmeLife = 8;\r\n        var detectionFactor = 1.5;\r\n\r\n        if(candleList.size < mmeLife ) {\r\n            return false; //insuficiente pra calcular a média do corpo.\r\n        }\r\n\r\n        //o tamanho da parte é 1.5x maior que a MME(mmeLife).\r\n        var mme = indicatorService.MMEUS(candleList, mmeLife ).pop().pop();\r\n\r\n        if(mme === null)\r\n            return false;\r\n\r\n        //console.log(candle.getLowerShadow(),mme,candle.getLowerShadow()/mme);\r\n        return ( mme / candle.getUpperShadow()) > detectionFactor;\r\n    };\r\n\r\n});","/**\r\n * Created by Ian on 02/01/2017.\r\n */\r\n","app.service(\"indicatorService\",function() {\r\n    var self = this;\r\n\r\n    self.tops = [];\r\n    self.bottoms = [];\r\n    self.trenchs = [];\r\n    self.tendencies = [];\r\n    self.trenchVariability = 0.02; //centavos\r\n    self.trenchLifeTime = 190; //trincheiras cujo indice seja menor do que o tamanho da lista - esse valor não serão consideradas.\r\n    self.trenchConfirmations = 2;\r\n    self.topBottomConfirmations = 1;\r\n    self.tendencyType  = {\r\n        UNDEFINED: 999,\r\n        BULLISH: 1,\r\n        NEUTRAL: 0,\r\n        BEARISH: -1,\r\n    };\r\n\r\n\r\n\r\n    self.findTrenchs = function(candleList) {\r\n\r\n        //inicialmente, todos os topos/fundos (dentro da margem de erro) são trincheira.\r\n        //a cada toque de um topo ou fundo em uma trincheira, sua força aumenta.\r\n        // mas se a trincheira for desrespeitada, sua força é zerada.\r\n        //ao final do processo, apenas trincheiras com força self.trenchConfirmations serão consideradas válidas.\r\n\r\n\r\n        //provável reversão de tendência = trincheira.\r\n        self.trenchs = [];\r\n        self.findTopsBottoms(candleList);\r\n\r\n        var first = self.tops;\r\n        var second =  self.bottoms;\r\n        //var firstType = self.tendencyType.BEARISH;\r\n       // var secondType = self.tendencyType.BULLISH;\r\n\r\n        if(first.length > 0 && second.lengh > 0) {\r\n            if(first[0].index > second[0].index) {\r\n                second = self.tops;\r\n                first =  self.bottoms;\r\n               // secondType = self.tendencyType.BEARISH;\r\n                //firstType = self.tendencyType.BULLISH;\r\n            }\r\n        }\r\n\r\n        first.forEach(function(element){\r\n\r\n            trenchIndex = self.trenchs.findIndex(function(trench){\r\n\r\n                return element.value >= trench.value - self.trenchVariability && element.value <= trench.value + self.trenchVariability;\r\n            });\r\n            // console.log(trenchIndex);\r\n            if(trenchIndex === -1) {\r\n                self.trenchs.push({value : element.value, strength: 0, index: element.index});\r\n            }\r\n\r\n        });\r\n\r\n        second.forEach(function(element){\r\n\r\n            trenchIndex = self.trenchs.findIndex(function(trench){\r\n                return element.value >= trench.value - self.trenchVariability && element.value <= trench.value + self.trenchVariability;\r\n            });\r\n            //console.log(trenchIndex);\r\n            if(trenchIndex === -1) {\r\n                self.trenchs.push({value : element.value, strength: 0, index: element.index});\r\n            }\r\n        });\r\n\r\n\r\n\r\n        //resistencia, suporte\r\n\r\n        self.trenchs = self.trenchs.sort(function(a,b){\r\n           return a.value - b.value;\r\n        });\r\n\r\n        //console.log(self.trenchs);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        //dividir a candlelist em chunks e processar cada chunk assincronamente.\r\n/*\r\n        var buffer  = [];\r\n        candleList.forEach(function(candle,index){\r\n\r\n            candle.index = index;\r\n            buffer.push(candle);\r\n            if(buffer.length === 50 || index+1 === candleList.length) {\r\n                //processar e esvaziar buffer.\r\n                (new Promise(function (fulfill) {\r\n                    buffer.forEach(function(candle){\r\n                        var i = candle.index;\r\n                        if(i < 1)\r\n                            return;\r\n\r\n                        //apenas as trincheiras descobertas no momento.\r\n                        var currentTrenchs =  self.trenchs.filter(function(trench){\r\n                            return trench.index < i;\r\n                        });\r\n\r\n\r\n                        if(currentTrenchs.length < 0)\r\n                            return;\r\n\r\n\r\n                        //achar a resistência e o suporte do candle anterior.\r\n                        var lastCandle = candleList[i-1];\r\n\r\n                        currentTrenchs.push({value:lastCandle.close,candle : true});\r\n\r\n                        currentTrenchs = currentTrenchs.sort(function(a,b){\r\n                            return a.value - b.value;\r\n                        });\r\n\r\n                        var position = currentTrenchs.findIndex(function(trench){\r\n                            return typeof trench.candle !== 'undefined';\r\n                        });\r\n\r\n                        var supportIndex = position-1;\r\n                        var resistanceIndex = position;\r\n\r\n                        currentTrenchs = currentTrenchs.filter(function(trench){\r\n                            return typeof trench.candle === 'undefined';\r\n                        });\r\n\r\n                        supportIndex = typeof currentTrenchs[supportIndex] === 'undefined' ? -1 : supportIndex;\r\n                        resistanceIndex = typeof currentTrenchs[resistanceIndex] === 'undefined' ? -1 : resistanceIndex;\r\n\r\n\r\n                        if(supportIndex === -1 && resistanceIndex === -1)\r\n                            return;\r\n\r\n\r\n\r\n                        if(supportIndex !== -1) { //existe suporte.\r\n                            var trenchIndex = supportIndex;\r\n                            var trench = currentTrenchs[trenchIndex];\r\n                            if(candle.close > trench.value + self.trenchVariability) {\r\n                                //console.log(\"houve rompimento.+\");\r\n                                //self.trenchs[trenchIndex].strength--;\r\n                            }\r\n                            else if(lastCandle.close >= trench.value - self.trenchVariability &&\r\n                                lastCandle.close <= trench.value + self.trenchVariability &&\r\n                                candle.close <= trench.value + self.trenchVariability\r\n                            ) {\r\n                                //console.log(\"houve toque e a trincheira foi respeitada.+\");\r\n                                self.trenchs[trenchIndex].strength++;\r\n                            }\r\n                        }\r\n\r\n                        if(resistanceIndex !== -1) { //existe resistência.\r\n                            var trenchIndex = resistanceIndex;\r\n                            var trench = currentTrenchs[trenchIndex];\r\n                            if(candle.close < trench.value - self.trenchVariability) {\r\n                                //console.log(\"houve rompimento.-\");\r\n                                //self.trenchs[trenchIndex].strength--;\r\n                            }\r\n                            else if(lastCandle.close >= trench.value - self.trenchVariability &&\r\n                                lastCandle.close <= trench.value + self.trenchVariability &&\r\n                                candle.close  >= trench.value - self.trenchVariability\r\n                            ) {\r\n                                //console.log(\"houve toque e a trincheira foi respeitada.-\");\r\n                                self.trenchs[trenchIndex].strength++;\r\n                            }\r\n                        }\r\n\r\n\r\n                    });\r\n                    fulfill('processado: ' + (index-20) + \" \" + index);\r\n                })).then(function(data){\r\n                    console.log(data);\r\n                });\r\n                buffer = [];\r\n            }\r\n        });\r\n\r\n*/\r\n        candleList.forEach(function(candle,i){\r\n            if(i < 1)\r\n                return;\r\n\r\n            //apenas as trincheiras descobertas no momento.\r\n            var currentTrenchs =  self.trenchs.filter(function(trench){\r\n                return trench.index < i;\r\n            });\r\n\r\n\r\n            if(currentTrenchs.length < 0)\r\n                return;\r\n\r\n\r\n            //achar a resistência e o suporte do candle anterior.\r\n            var lastCandle = candleList[i-1];\r\n\r\n            currentTrenchs.push({value:lastCandle.close,candle : true});\r\n\r\n            currentTrenchs = currentTrenchs.sort(function(a,b){\r\n                return a.value - b.value;\r\n            });\r\n\r\n            var position = currentTrenchs.findIndex(function(trench){\r\n                return typeof trench.candle !== 'undefined';\r\n            });\r\n\r\n            var supportIndex = position-1;\r\n            var resistanceIndex = position;\r\n\r\n            currentTrenchs = currentTrenchs.filter(function(trench){\r\n                return typeof trench.candle === 'undefined';\r\n            });\r\n\r\n            supportIndex = typeof currentTrenchs[supportIndex] === 'undefined' ? -1 : supportIndex;\r\n            resistanceIndex = typeof currentTrenchs[resistanceIndex] === 'undefined' ? -1 : resistanceIndex;\r\n\r\n\r\n            if(supportIndex === -1 && resistanceIndex === -1)\r\n                return;\r\n\r\n\r\n\r\n            if(supportIndex !== -1) { //existe suporte.\r\n                var trenchIndex = supportIndex;\r\n                var trench = currentTrenchs[trenchIndex];\r\n                if(candle.close > trench.value + self.trenchVariability) {\r\n                    //console.log(\"houve rompimento.+\");\r\n                    //self.trenchs[trenchIndex].strength--;\r\n                }\r\n                else if(lastCandle.close >= trench.value - self.trenchVariability &&\r\n                        lastCandle.close <= trench.value + self.trenchVariability &&\r\n                        candle.close <= trench.value + self.trenchVariability\r\n                ) {\r\n                    //console.log(\"houve toque e a trincheira foi respeitada.+\");\r\n                    self.trenchs[trenchIndex].strength++;\r\n                }\r\n            }\r\n\r\n            if(resistanceIndex !== -1) { //existe resistência.\r\n                var trenchIndex = resistanceIndex;\r\n                var trench = currentTrenchs[trenchIndex];\r\n                if(candle.close < trench.value - self.trenchVariability) {\r\n                    //console.log(\"houve rompimento.-\");\r\n                    //self.trenchs[trenchIndex].strength--;\r\n                }\r\n                else if(lastCandle.close >= trench.value - self.trenchVariability &&\r\n                    lastCandle.close <= trench.value + self.trenchVariability &&\r\n                    candle.close  >= trench.value - self.trenchVariability\r\n                ) {\r\n                    //console.log(\"houve toque e a trincheira foi respeitada.-\");\r\n                    self.trenchs[trenchIndex].strength++;\r\n                }\r\n            }\r\n\r\n\r\n        });\r\n\r\n        //console.log(self.trenchs );\r\n        self.trenchs = self.trenchs.filter(function(trench){\r\n            return trench.strength >= self.trenchConfirmations ;\r\n        });\r\n        //console.log(self.trenchs );\r\n\r\n    };\r\n\r\n    self.findTrenchsBack = function(candleList) {\r\n\r\n        //inicialmente, todos os topos/fundos (dentro da margem de erro) são trincheira.\r\n        //a cada toque de um topo ou fundo em uma trincheira, sua força aumenta.\r\n        // mas se a trincheira for desrespeitada, sua força é zerada.\r\n        //ao final do processo, apenas trincheiras com força self.trenchConfirmations serão consideradas válidas.\r\n\r\n\r\n        //provável reversão de tendência = trincheira.\r\n        self.trenchs = [];\r\n        self.findTopsBottoms(candleList);\r\n        var candleListLength = candleList.length;\r\n\r\n        var minIndex = Math.max(0,candleListLength - self.trenchLifeTime);\r\n        //console.log(minIndex);\r\n        self.tops.forEach(function(top){\r\n            if(top.index < minIndex )\r\n                return;\r\n\r\n            trenchIndex = self.trenchs.findIndex(function(trench){\r\n                //console.log(top.value,top.value * (1-self.trenchVariability), \"<=\" , trench.value, \"<=\" ,top.value * (1+self.trenchVariability) );\r\n                return trench.value > top.value - self.trenchVariability && trench.value < top.value + self.trenchVariability ;\r\n            });\r\n                       // console.log(trenchIndex);\r\n            if(trenchIndex !== -1) {\r\n\r\n                self.trenchs[trenchIndex].strength++;\r\n            }\r\n            else {\r\n                self.trenchs.push({value : top.value, strength: 1});\r\n            }\r\n        });\r\n\r\n        self.bottoms.forEach(function(bottom){\r\n\r\n            if(bottom.index  < minIndex)\r\n                return;\r\n\r\n            trenchIndex = self.trenchs.findIndex(function(trench){\r\n                //onsole.log(bottom.value,bottom.value * (1-self.trenchVariability), \"<=\" , trench.value, \"<=\" ,bottom.value * (1+self.trenchVariability) );\r\n                return trench.value >= bottom.value * (1-self.trenchVariability) && trench.value <= bottom.value * (1+self.trenchVariability);\r\n            });\r\n            //console.log(trenchIndex);\r\n            if(trenchIndex !== -1) {\r\n                self.trenchs[trenchIndex].strength++;\r\n            }\r\n            else {\r\n                self.trenchs.push({value : bottom.value, strength: 1});\r\n            }\r\n        });\r\n        //console.log(self.trenchs );\r\n        self.trenchs = self.trenchs.filter(function(trench){\r\n            return trench.strength >= self.trenchConfirmations ;\r\n        });\r\n    };\r\n\r\n    self.findTopsBottoms = function (candleList) {\r\n\r\n\r\n        self.tops = [];\r\n        self.bottoms = [];\r\n\r\n        var tb = [];\r\n        var confirmations = {\r\n            need: self.topBottomConfirmations,\r\n            top: 0,\r\n            bottom: 0\r\n        };\r\n\r\n        var iterator;\r\n        //detectandop topos e fundos;\r\n        candleList.forEach(function(candle,i) {\r\n            if(i < confirmations.need || i >= candleList.length - confirmations.need) //minimo e máximo\r\n                return;\r\n\r\n            if(candle.max < candleList[i-1].max && candle.min > candleList[i-1].min) {\r\n                return; //inside bar, n representa evolução\r\n            }\r\n            confirmations.top = confirmations.bottom = 0;\r\n            for(iterator = 1; iterator <= confirmations.need; iterator++) {\r\n                if(candleList[i - iterator].max <= candle.max && candleList[i + iterator].max <= candle.max) {\r\n                    confirmations.top++;\r\n                }\r\n                if(candleList[i - iterator].min >= candle.min && candleList[i + iterator].min >= candle.min) {\r\n                    confirmations.bottom++;\r\n                }\r\n            };\r\n\r\n            //detectando topos\r\n            if(confirmations.top === confirmations.need) {\r\n\r\n\r\n                if(tb.length === 0) { //adiciona logo\r\n                    tb.push({\r\n                        index: i,\r\n                        value: candle.max,\r\n                        type: self.tendencyType.BULLISH //topo\r\n                    });\r\n                    return;\r\n                }\r\n                else if( tb[tb.length-1].type !== self.tendencyType.BULLISH) { //ultimo contrário\r\n                    if(i - tb[tb.length-1].index >= 2 || (((candle.max / tb[tb.length-1].value)  - 1) * 100) > 3 ) {\r\n                        tb.push({\r\n                            index: i,\r\n                            value: candle.max,\r\n                            type: self.tendencyType.BULLISH //topo\r\n                        });\r\n                        return;\r\n                    }\r\n                }\r\n                else {\r\n                    if(tb[tb.length-1].value <= candle.max) {\r\n                        tb[tb.length-1].value = candle.max;\r\n                        tb[tb.length-1].index = i;\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n\r\n            //detectando fundos\r\n            if(confirmations.bottom === confirmations.need) {\r\n\r\n\r\n                if(tb.length === 0) { //adiciona logo\r\n                    tb.push({\r\n                        index: i,\r\n                        value: candle.min,\r\n                        type: self.tendencyType.BEARISH //fundo\r\n                    });\r\n                    return;\r\n                }\r\n                else if( tb[tb.length-1].type !== self.tendencyType.BEARISH) { //ultimo contrário\r\n                    if(i - tb[tb.length-1].index >= 2 || (((tb[tb.length-1].value / candle.min )  - 1) * 100) > 3 ) {\r\n                        tb.push({\r\n                            index: i,\r\n                            value: candle.min,\r\n                            type: self.tendencyType.BEARISH //fundo\r\n                        });\r\n                        return;\r\n                    }\r\n                }\r\n                else {\r\n                    if(tb[tb.length-1].value >= candle.min) {\r\n                        tb[tb.length-1].value = candle.min;\r\n                        tb[tb.length-1].index = i;\r\n                    }\r\n                }\r\n            }\r\n\r\n        });\r\n\r\n        tb.forEach(function(t){\r\n            if(t.type === self.tendencyType.BULLISH) {\r\n                self.tops.push(t);\r\n            }\r\n            else {\r\n                self.bottoms.push(t);\r\n            }\r\n        });\r\n\r\n    };\r\n    self.findTendencies = function(candleList) {\r\n\r\n        self.findTopsBottoms(candleList);\r\n\r\n        //detecção de tendências\r\n        self.tendencies = [];\r\n\r\n        var inclinations = {\r\n            top: [],\r\n            bottom: []\r\n        };\r\n\r\n        self.tops.forEach(function(top,i) {\r\n           if(i < 1) {\r\n               return;\r\n           }\r\n\r\n           var cur;\r\n           if(self.tops[i-1].value < top.value) {\r\n               cur = self.tendencyType.BULLISH;\r\n           }\r\n            if(self.tops[i-1].value > top.value) {\r\n                cur = self.tendencyType.BEARISH;\r\n            }\r\n            if(self.tops[i-1].value === top.value) {\r\n                cur = self.tendencyType.NEUTRAL;\r\n            }\r\n\r\n            inclinations.top.push({inc: cur, index: self.tops[i-1].index});\r\n        });\r\n        self.bottoms.forEach(function(bottom,i) {\r\n            if(i < 1) {\r\n                return;\r\n            }\r\n\r\n            var cur;\r\n            if(self.bottoms[i-1].value < bottom.value) {\r\n                cur = self.tendencyType.BULLISH;\r\n            }\r\n            if(self.bottoms[i-1].value > bottom.value) {\r\n                cur = self.tendencyType.BEARISH;\r\n            }\r\n            if(self.bottoms[i-1].value === bottom.value) {\r\n                cur = self.tendencyType.NEUTRAL;\r\n            }\r\n\r\n            inclinations.bottom.push({inc: cur, index: self.bottoms[i-1].index});\r\n        });\r\n\r\n        var maxIteration = Math.max(inclinations.top.length,inclinations.bottom.length);\r\n\r\n        var currentTendency = self.tendencyType.UNDEFINED;\r\n        for(var i = 0; i < maxIteration; i++) {\r\n\r\n\r\n            //TODO: testar pegar o ponto índice mais próximo para comparação.\r\n\r\n\r\n            var iterators = {\r\n                top: i,\r\n                bottom: i\r\n            };\r\n            if(typeof inclinations.top[iterators[\"top\"]] === 'undefined') {\r\n                iterators[\"top\"] -= 1;\r\n            }\r\n            if(typeof inclinations.bottom[iterators[\"bottom\"]]=== 'undefined') {\r\n                iterators[\"bottom\"] -= 1;\r\n            }\r\n\r\n            //se qualquer um dos dois for < 0, tendencia neutra;\r\n            if(iterators[\"top\"]  < 0) {\r\n                currentTendency = currentTendency = self.tendencyType.NEUTRAL;\r\n                self.tendencies.push({\r\n                    index: inclinations.bottom[iterators[\"bottom\"]].index,\r\n                    pair: inclinations.bottom[iterators[\"bottom\"]].index,\r\n                    type: currentTendency\r\n                });\r\n                continue;\r\n            }\r\n            if(iterators[\"bottom\"]  < 0) {\r\n                currentTendency = currentTendency = self.tendencyType.NEUTRAL;\r\n                self.tendencies.push({\r\n                    index: inclinations.top[iterators[\"top\"]].index,\r\n                    pair: inclinations.top[iterators[\"top\"]].index,\r\n                    type: currentTendency\r\n                });\r\n                continue;\r\n            }\r\n\r\n\r\n            if(inclinations.top[iterators[\"top\"]].inc === inclinations.bottom[iterators[\"bottom\"]].inc) { //concordância de inclinação\r\n                if(inclinations.top[iterators[\"top\"]].inc !== currentTendency) { //mudança de tendência.\r\n                    currentTendency = inclinations.top[iterators[\"top\"]].inc;\r\n                    self.tendencies.push({\r\n                        index: Math.min(inclinations.top[iterators[\"top\"]].index, inclinations.bottom[iterators[\"bottom\"]].index),\r\n                        pair: Math.max(inclinations.top[iterators[\"top\"]].index,inclinations.bottom[iterators[\"bottom\"]].index),\r\n                        type: currentTendency\r\n                    });\r\n                }\r\n            }\r\n            else { //divergência de inclinação.\r\n\r\n                //verificar se divergência continua com topo/fundo anterior.\r\n                if(i > 0) {\r\n                    var first = \"top\";\r\n                    var second = \"bottom\";\r\n                    if(inclinations.bottom[iterators[\"bottom\"]].index < inclinations.top[iterators[\"top\"]].index){ //bottom vem primeiro\r\n                        first = \"bottom\";\r\n                        second = \"top\";\r\n                    }\r\n\r\n                    //verificar anterior\r\n                    if(inclinations[first][iterators[first]].inc === inclinations[second][iterators[second] -1].inc) { //concordância encontrada\r\n                        if(inclinations[first][iterators[first]].inc !== currentTendency) { //mudança de tendência.\r\n                            currentTendency = inclinations[first][iterators[first]].inc;\r\n                            self.tendencies.push({\r\n                                index: Math.min(inclinations[second][iterators[second] -1].index, inclinations[first][iterators[first]].index),\r\n                                pair: Math.max(inclinations[second][iterators[second] -1].index,inclinations[first][iterators[first]].index),\r\n                                type: currentTendency\r\n                            });\r\n                        }\r\n                    }\r\n                    else { //se ainda continuar divergente.\r\n                        if(currentTendency !== self.tendencyType.NEUTRAL) {\r\n                            currentTendency = self.tendencyType.NEUTRAL;\r\n                            self.tendencies.push({\r\n                                index: Math.min(inclinations.top[iterators[\"top\"]].index, inclinations.bottom[iterators[\"bottom\"]].index),\r\n                                pair: Math.max(inclinations.top[iterators[\"top\"]].index, inclinations.bottom[iterators[\"bottom\"]].index),\r\n                                type: currentTendency\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        //console.log(self.tendencies);\r\n\r\n    };\r\n    self.getActualTendency = function(candleList){\r\n        self.findTendencies(candleList);\r\n\r\n        if(self.tendencies.length === 0) {\r\n            return {\r\n                index: candleList.length-1,\r\n                pair: candleList.length-1,\r\n                type: self.tendencyType.UNDEFINED\r\n            }\r\n        }\r\n        return self.tendencies[self.tendencies.length-1];\r\n    };\r\n\r\n    //media movel exponencial dos valores de um indicador\r\n    self.MMEIndicator = function(indicatorList,periods) {\r\n\r\n        var i;\r\n        var mme = [];\r\n        var sum;\r\n\r\n        //zerando os primeiros valores\r\n        for(i = 0; i < periods && i < indicatorList.length; i++){\r\n            mme.push([null]);\r\n        }\r\n\r\n\r\n        if(i ===  indicatorList.length) //ainda n tem periodos suficientes pra calcular.\r\n            return mme;\r\n\r\n        //calculando a primeira média, q não é exponencial.\r\n        sum = 0;\r\n        for(i = 0; i < periods; i++) {\r\n            //console.log(i,candleList[i].open);\r\n            sum += indicatorList[i][0];\r\n        }\r\n        sum /= periods;\r\n        mme.push([sum]);\r\n\r\n        //calculando as exponenciais\r\n        for(i = periods; i < indicatorList.length-1; i++ ) {\r\n\r\n            mme.push([((indicatorList[i][0] - mme[i][0]) * (2/(periods+1) )) + mme[i][0]]);\r\n            //console.log(result[i],candleList[i].open,i);\r\n        }\r\n        return mme;\r\n\r\n    };\r\n\r\n\r\n\r\n\r\n\r\n\r\n    //media movel exponencial da abertura\r\n    self.MMEO = function(candleList,periods){\r\n\r\n        var i;\r\n        var mme = [];\r\n        var sum;\r\n\r\n        //zerando os primeiros valores\r\n        for(i = 0; i < periods && i < candleList.length; i++){\r\n            mme.push([null]);\r\n        }\r\n\r\n\r\n        if(i ===  candleList.length) //ainda n tem periodos suficientes pra calcular.\r\n            return mme;\r\n\r\n        //calculando a primeira média, q não é exponencial.\r\n        sum = 0;\r\n        for(i = 0; i < periods; i++) {\r\n            //console.log(i,candleList[i].open);\r\n            sum += candleList[i].open;\r\n        }\r\n        sum /= periods;\r\n        mme.push([sum]);\r\n\r\n        //calculando as exponenciais\r\n        for(i = periods; i < candleList.length-1; i++ ) {\r\n\r\n            mme.push([((candleList[i].open - mme[i][0]) * (2/(periods+1) )) + mme[i][0]]);\r\n            //console.log(result[i],candleList[i].open,i);\r\n        }\r\n        return mme;\r\n    };\r\n    //media movel exponencial do fechamento\r\n    self.MMEC = function(candleList,periods){\r\n        var i;\r\n        var mme = [];\r\n        var sum;\r\n\r\n        //zerando os primeiros valores\r\n        for(i = 0; i < periods && i < candleList.length; i++){\r\n            mme.push([null]);\r\n        }\r\n\r\n\r\n        if(i ===  candleList.length) //ainda n tem periodos suficientes pra calcular.\r\n            return mme;\r\n\r\n        //calculando a primeira média, q não é exponencial.\r\n        sum = 0;\r\n        for(i = 0; i < periods; i++) {\r\n            //console.log(i,candleList[i].close);\r\n            sum += candleList[i].close;\r\n        }\r\n        sum /= periods;\r\n        mme.push([sum]);\r\n\r\n        //calculando as exponenciais\r\n        for(i = periods; i < candleList.length-1; i++ ) {\r\n\r\n            mme.push([((candleList[i].close - mme[i][0]) * (2/(periods+1) )) + mme[i][0]]);\r\n            //console.log(result[i],candleList[i].close,i);\r\n        }\r\n        return mme;\r\n    };\r\n    //media movel exponencial da máxima\r\n    self.MMEH = function(candleList,periods){\r\n        var i;\r\n        var mme = [];\r\n        var sum;\r\n\r\n        //zerando os primeiros valores\r\n        for(i = 0; i < periods && i < candleList.length; i++){\r\n            mme.push([null]);\r\n        }\r\n\r\n\r\n        if(i ===  candleList.length) //ainda n tem periodos suficientes pra calcular.\r\n            return mme;\r\n\r\n        //calculando a primeira média, q não é exponencial.\r\n        sum = 0;\r\n        for(i = 0; i < periods; i++) {\r\n            //console.log(i,candleList[i].max);\r\n            sum += candleList[i].max;\r\n        }\r\n        sum /= periods;\r\n        mme.push([sum]);\r\n\r\n        //calculando as exponenciais\r\n        for(i = periods; i < candleList.length-1; i++ ) {\r\n\r\n            mme.push([((candleList[i].max - mme[i][0]) * (2/(periods+1) )) + mme[i][0]]);\r\n            //console.log(result[i],candleList[i].max,i);\r\n        }\r\n        return mme;\r\n    };\r\n    //media movel exponencial da minima\r\n    self.MMEL = function(candleList,periods){\r\n        var i;\r\n        var mme = [];\r\n        var sum;\r\n\r\n        //zerando os primeiros valores\r\n        for(i = 0; i < periods && i < candleList.length; i++){\r\n            mme.push([null]);\r\n        }\r\n\r\n\r\n        if(i ===  candleList.length) //ainda n tem periodos suficientes pra calcular.\r\n            return mme;\r\n\r\n        //calculando a primeira média, q não é exponencial.\r\n        sum = 0;\r\n        for(i = 0; i < periods; i++) {\r\n            //console.log(i,candleList[i].min);\r\n            sum += candleList[i].min;\r\n        }\r\n        sum /= periods;\r\n        mme.push([sum]);\r\n\r\n        //calculando as exponenciais\r\n        for(i = periods; i < candleList.length-1; i++ ) {\r\n\r\n            mme.push([((candleList[i].min - mme[i][0]) * (2/(periods+1) )) + mme[i][0]]);\r\n            //console.log(result[i],candleList[i].min,i);\r\n        }\r\n        return mme;\r\n    };\r\n    //media movel exponencial da amplitude do corpo\r\n    self.MMEB = function(candleList,periods){\r\n        var i;\r\n        var mme = [];\r\n        var sum;\r\n\r\n        //zerando os primeiros valores\r\n        for(i = 0; i < periods && i < candleList.length; i++){\r\n            mme.push([null]);\r\n        }\r\n\r\n\r\n        if(i ===  candleList.length) //ainda n tem periodos suficientes pra calcular.\r\n            return mme;\r\n\r\n        //calculando a primeira média, q não é exponencial.\r\n        sum = 0;\r\n        for(i = 0; i < periods; i++) {\r\n            //console.log(i,candleList[i].getBody());\r\n            sum += candleList[i].getBody();\r\n        }\r\n        sum /= periods;\r\n        mme.push([sum]);\r\n\r\n        //calculando as exponenciais\r\n        for(i = periods; i < candleList.length-1; i++ ) {\r\n\r\n            mme.push([((candleList[i].getBody() - mme[i][0]) * (2/(periods+1) )) + mme[i][0]]);\r\n            //console.log(result[i],candleList[i].getBody(),i);\r\n        }\r\n        return mme;\r\n    };\r\n    //media movel exponencial da amplitude da sompra superior\r\n    self.MMEUS = function(candleList,periods){\r\n        var i;\r\n        var mme = [];\r\n        var sum;\r\n\r\n        //zerando os primeiros valores\r\n        for(i = 0; i < periods && i < candleList.length; i++){\r\n            mme.push([null]);\r\n        }\r\n\r\n\r\n        if(i ===  candleList.length) //ainda n tem periodos suficientes pra calcular.\r\n            return mme;\r\n\r\n        //calculando a primeira média, q não é exponencial.\r\n        sum = 0;\r\n        for(i = 0; i < periods; i++) {\r\n            //console.log(i,candleList[i].getUpperShadow());\r\n            sum += candleList[i].getUpperShadow();\r\n        }\r\n        sum /= periods;\r\n        mme.push([sum]);\r\n\r\n        //calculando as exponenciais\r\n        for(i = periods; i < candleList.length-1; i++ ) {\r\n\r\n            mme.push([((candleList[i].getUpperShadow() - mme[i][0]) * (2/(periods+1) )) + mme[i][0]]);\r\n            //console.log(result[i],candleList[i].getUpperShadow(),i);\r\n        }\r\n        return mme;\r\n    };\r\n    //media movel exponencial da amplitude da sompra inferior\r\n    self.MMELS = function(candleList,periods){\r\n        var i;\r\n        var mme = [];\r\n        var sum;\r\n\r\n        //zerando os primeiros valores\r\n        for(i = 0; i < periods && i < candleList.length; i++){\r\n            mme.push([null]);\r\n        }\r\n\r\n\r\n        if(i ===  candleList.length) //ainda n tem periodos suficientes pra calcular.\r\n            return mme;\r\n\r\n        //calculando a primeira média, q não é exponencial.\r\n        sum = 0;\r\n        for(i = 0; i < periods; i++) {\r\n            //console.log(i,candleList[i].getLowerShadow());\r\n            sum += candleList[i].getLowerShadow();\r\n        }\r\n        sum /= periods;\r\n        mme.push([sum]);\r\n\r\n        //calculando as exponenciais\r\n        for(i = periods; i < candleList.length-1; i++ ) {\r\n\r\n            mme.push([((candleList[i].getLowerShadow() - mme[i][0]) * (2/(periods+1) )) + mme[i][0]]);\r\n            //console.log(result[i],candleList[i].getLowerShadow(),i);\r\n        }\r\n        return mme;\r\n    };\r\n    self.MMS = function(candleList,periods){\r\n        var i;\r\n        var iGroup;\r\n        var sum;\r\n        var mms = [];\r\n\r\n        //zerando os primeiros valores\r\n        for(i = 0; i < periods && i < candleList.length; i++){\r\n            mms.push([null]);\r\n        }\r\n\r\n        if(i ===  candleList.length) //ainda n tem periodos suficientes pra calcular.\r\n            return mms;\r\n\r\n        for(i = periods; i < candleList.length; i++ ) {\r\n            sum = 0;\r\n            for (iGroup = i - 1; iGroup >= i - periods; iGroup--) {\r\n                sum += candleList[iGroup].close;\r\n            }\r\n            mms.push([sum / periods]);\r\n        }\r\n        return mms;\r\n    };\r\n\r\n    self.volumeMMS = function(candleList,periods){\r\n        var i;\r\n        var iGroup;\r\n        var sum;\r\n        var mms = [];\r\n\r\n        //zerando os primeiros valores\r\n        for(i = 0; i < periods && i < candleList.length; i++){\r\n            mms.push([null]);\r\n        }\r\n\r\n        if(i ===  candleList.length) //ainda n tem periodos suficientes pra calcular.\r\n            return mms;\r\n\r\n        for(i = periods; i < candleList.length; i++ ) {\r\n            sum = 0;\r\n            for (iGroup = i - 1; iGroup >= i - periods; iGroup--) {\r\n                sum += candleList[iGroup].volume;\r\n            }\r\n            mms.push([sum / periods]);\r\n        }\r\n        return mms;\r\n    };\r\n    self.IFR = function(candleList,periods){ //TODO: parece que o calculo ta errado...\r\n\r\n        var ifr = [];\r\n        var gainSum = 0;\r\n        var lossSum = 0;\r\n        var value;\r\n        var i;\r\n        var iGroup;\r\n        var gainAverage;\r\n        var lossAverage;\r\n        var fr;\r\n\r\n        //iniciando os primeiros valores\r\n        for(i = 0; i < periods && i < candleList.length; i++){\r\n            value = candleList[i].open - candleList[i].close;\r\n            if(value > 0 ) {\r\n                gainSum += value;\r\n            }\r\n            else {\r\n                lossSum += value * -1;\r\n            }\r\n            ifr.push([null]);\r\n        }\r\n\r\n        if(i ===  candleList.length) //ainda n tem periodos suficientes pra calcular.\r\n            return ifr;\r\n\r\n\r\n        gainAverage = gainSum / periods;\r\n        lossAverage = lossSum / periods;\r\n\r\n\r\n        for(i = periods; i < candleList.length; i++ ) {\r\n\r\n            gainSum = 0;\r\n            lossSum = 0;\r\n\r\n            for(iGroup = i-1; iGroup >= i-periods; iGroup--) {\r\n                value = candleList[iGroup].open - candleList[iGroup].close;\r\n                if(value > 0 ) {\r\n                    gainSum += value;\r\n                }\r\n                else {\r\n                    lossSum += value * -1;\r\n                }\r\n            }\r\n\r\n            gainAverage = ((gainAverage * (periods - 1)) + gainSum) / periods;\r\n            lossAverage = ((lossAverage * (periods - 1)) + lossSum) / periods;\r\n\r\n            fr = gainAverage / lossAverage;\r\n\r\n            ifr.push([\r\n                100 - (100 / (1 + fr))\r\n            ])\r\n        }\r\n\r\n\r\n        return ifr;\r\n    };\r\n    self.accumDist = function(candleList){\r\n        var lastAdl = 0;\r\n        var fd;\r\n        var vfd;\r\n        var adl;\r\n        var ac = [];\r\n\r\n        candleList.forEach(function(candle){\r\n\r\n            //fluxo de dinheiro\r\n            fd = ((candle.close - candle.min) - (candle.max - candle.close)) / (candle.max - candle.min);\r\n            //volume do fluxo de dinheiro\r\n            vfd = fd * candle.volume;\r\n\r\n            adl = lastAdl  + vfd;\r\n            lastAdl = adl;\r\n            ac.push([adl]);\r\n        });\r\n\r\n        return ac;\r\n    };\r\n    self.bollinger = function(candleList,periods) {\r\n\r\n        var i,iGroup;\r\n        var bollinger = [];\r\n        var sum;\r\n        var sumSquare;\r\n        var mms;\r\n        var variancia;\r\n        var desvio_padrao;\r\n\r\n        //zerando os primeiros valores\r\n        for(i = 0; i < periods && i < candleList.length; i++){\r\n            bollinger.push([null,null]);\r\n        }\r\n\r\n        if(i ===  candleList.length) //ainda n tem periodos suficientes pra calcular.\r\n            return bollinger;\r\n\r\n\r\n        //calculando as bandas\r\n        for(i = periods; i < candleList.length; i++ ) {\r\n\r\n          sum = 0;\r\n          sumSquare = 0;\r\n\r\n          //console.log(\"--\",i,candleList.length);\r\n          for(iGroup = i-1; iGroup >= i-periods; iGroup--) {\r\n              //console.log(iGroup);\r\n              sum += candleList[iGroup].close;\r\n              sumSquare += Math.pow(candleList[iGroup].close,2);\r\n          }\r\n\r\n          mms = sum / periods;\r\n          variancia = (sumSquare / periods) - Math.pow(mms,2);\r\n          desvio_padrao = Math.sqrt(variancia);\r\n\r\n          //console.log(sum,sumSquare,mms,sumSquare / periods,Math.pow(mms,2),variancia,desvio_padrao);\r\n\r\n\r\n          bollinger.push([mms + (2*desvio_padrao),mms - (2*desvio_padrao)]);\r\n\r\n        }\r\n\r\n        return bollinger;\r\n\r\n    };\r\n    self.bollingerWidth = function(candleList,periods) {\r\n\r\n        var i,iGroup;\r\n        var bollinger = [];\r\n        var sum;\r\n        var sumSquare;\r\n        var mms;\r\n        var variancia;\r\n        var desvio_padrao;\r\n\r\n        //zerando os primeiros valores\r\n        for(i = 0; i < periods && i < candleList.length; i++){\r\n            bollinger.push([null,null]);\r\n        }\r\n\r\n        if(i ===  candleList.length) //ainda n tem periodos suficientes pra calcular.\r\n            return bollinger;\r\n\r\n\r\n        //calculando as bandas\r\n        for(i = periods; i < candleList.length; i++ ) {\r\n\r\n            sum = 0;\r\n            sumSquare = 0;\r\n\r\n            //console.log(\"--\",i,candleList.length);\r\n            for(iGroup = i-1; iGroup >= i-periods; iGroup--) {\r\n                //console.log(iGroup);\r\n                sum += candleList[iGroup].close;\r\n                sumSquare += Math.pow(candleList[iGroup].close,2);\r\n            }\r\n\r\n            mms = sum / periods;\r\n            variancia = (sumSquare / periods) - Math.pow(mms,2);\r\n            desvio_padrao = Math.sqrt(variancia);\r\n\r\n            //console.log(sum,sumSquare,mms,sumSquare / periods,Math.pow(mms,2),variancia,desvio_padrao);\r\n            var upperBand  =  mms + (2*desvio_padrao);\r\n            var lowerBand  =  mms - (2*desvio_padrao);\r\n            var middleBand = mms;\r\n\r\n            //console.log(upperBand,lowerBand,middleBand,((upperBand - lowerBand) / middleBand) * 100 );\r\n            //((Upper Band - Lower Band) / Middle Band) * 100\r\n\r\n            bollinger.push([((upperBand - lowerBand) / middleBand) * 100]);\r\n        }\r\n\r\n        return bollinger;\r\n\r\n    };\r\n\r\n    self.debugBollingerPart = function(candleList,periods){\r\n        var bollinger = self.bollinger(candleList,periods);\r\n        var result = [];\r\n\r\n\r\n        bollinger.forEach(function(boll){\r\n            if(boll[0] === null) {\r\n                result.push([null]);\r\n                return;\r\n            }\r\n            result.push([boll[1] + (((boll[0]-boll[1]) / 8)*7)]);\r\n\r\n        });\r\n        return result;\r\n\r\n\r\n    };\r\n\r\n\r\n    self.drawLine = function(candlelist,value) {\r\n\r\n        var dump = [];\r\n        for(var i = 0; i < candlelist.length; i++)\r\n            dump.push([value]);\r\n        return dump;\r\n    };\r\n\r\n\r\n    self.DEBUG_getTops = function(candleList) {\r\n        var tops = [];\r\n        var found;\r\n\r\n        self.findTopsBottoms(candleList);\r\n\r\n        candleList.forEach(function(candle,candleIndex){\r\n            found = self.tops.find(function(top){\r\n                return top.index === candleIndex;\r\n            });\r\n\r\n            if(typeof found !== 'undefined') {\r\n                tops.push([found.value * 1.0003]);\r\n            }\r\n            else {\r\n                tops.push([null]);\r\n            }\r\n\r\n        });\r\n        return tops;\r\n    };\r\n    self.DEBUG_getBottoms = function(candleList) {\r\n        var bottoms = [];\r\n        var found;\r\n\r\n        self.findTopsBottoms(candleList);\r\n\r\n        candleList.forEach(function(candle,candleIndex){\r\n            found = self.bottoms.find(function(top){\r\n                return top.index === candleIndex;\r\n            });\r\n\r\n            if(typeof found !== 'undefined') {\r\n                bottoms.push([found.value * 0.9997]);\r\n            }\r\n            else {\r\n                bottoms.push([null]);\r\n            }\r\n\r\n        });\r\n        return bottoms;\r\n    };\r\n\r\n});","/**\r\n * Created by Ian on 06/01/2017.\r\n */\r\n\r\napp.service(\"opportunityService\",function($http,candleAnalysisService,indicatorService) {\r\n    var self = this;\r\n\r\n\r\n\r\n\r\n    self.applyOnList = function(strategyFunction,stockList,periodLength,callback){\r\n\r\n\r\n\r\n\r\n        stockList.forEach(function(stock,i){\r\n\r\n            var execute = function() {\r\n                url = \"stock/\" + stock.ticker + \"/trades/2000-01-01-00-00/2050-01-01-00-00/\" + periodLength + \"/0\";\r\n                $http.get(url).then(function (data) {\r\n\r\n                    var candles = [];\r\n                    //console.log(data.data);\r\n                    data.data.forEach(function (element) {\r\n\r\n                        var start = element.start.replace(\" \", \"-\")\r\n                        //.replace(\":\", \"-\");\r\n                            .replace(\":\", \"-\");\r\n\r\n\r\n                        var candle = new Candle(\r\n                            start,\r\n                            element.end,\r\n                            element.min,\r\n                            element.open,\r\n                            element.close,\r\n                            element.max,\r\n                            element.quantity\r\n                        );\r\n                        candle.exchange = element.exchange;\r\n                        candle.timestamp = element.timestamp;\r\n                        candles.push(candle);\r\n                    });\r\n                    var result = strategyFunction(candles);\r\n\r\n                    candles[candles.length-1].exchange = candles[0].exchange;\r\n                    if(result === true) {\r\n                        callback(stock.ticker, result,candles[candles.length-1],self.setStopAndTarget(candles[candles.length-1]));\r\n                    }\r\n                    else {\r\n                        callback(stock.ticker, result,candles[candles.length-1]);\r\n                    }\r\n                    //console.log(stock.ticker, result);\r\n                }, function (data) {\r\n                    //console.error(\"erro em\", url);\r\n                    setTimeout(function(){\r\n                        execute();\r\n                    }, 200);   //dar um tempo aqui.\r\n                });\r\n            };\r\n            setTimeout(function(){\r\n                execute();\r\n            }, 200 * i);   //dar um tempo aqui.\r\n\r\n        });\r\n    };\r\n\r\n\r\n    self.detectCongestion = function (candleList) {\r\n\r\n        //-de 1 indica bandas contraidas.\r\n        //razão: -de 0.31 eh contração.\r\n\r\n\r\n\r\n        var lastIndex = candleList.length-1;\r\n        ///bandas de bollinger contraidas.\r\n        var bw = indicatorService.bollingerWidth(candleList,20);\r\n        var bwMME = indicatorService.MMEIndicator(bw,20);\r\n        var max = bwMME[lastIndex][0];\r\n\r\n        for(i = 1; i <= 39; i++)\r\n            max = max < bwMME[lastIndex-i][0] ? bwMME[lastIndex-i][0] : max;\r\n\r\n\r\n\r\n        bwMME = bwMME[lastIndex][0] / max;\r\n\r\n\r\n        if(bwMME > 0.33)\r\n            return \"sem congestão\";\r\n\r\n\r\n\r\n        if(!candleList[lastIndex].isBullish())\r\n            return \"sem candle de alta\";\r\n\r\n        if(!candleAnalysisService.detect_LONG_BODY(candleList)) {\r\n            return \"sem candle de força\";\r\n        }\r\n\r\n        if(!candleAnalysisService.detect_SHORT_SHADOW_UPPER(candleList))\r\n            return \"sem fechamento próximo da máxima\";\r\n\r\n        //checar rompimento de resistência\r\n       indicatorService.findTrenchs(candleList);\r\n        var trench = indicatorService.trenchs.filter(function(trench){\r\n            return trench.value > candleList[lastIndex-1].close;\r\n\r\n        }).sort(function(a,b){\r\n            return a.value - b.value;\r\n        })[0];\r\n\r\n        if(typeof trench !== 'undefined') {\r\n\r\n            if(candleList[lastIndex].open < trench.value && candleList[lastIndex].close > trench.value) {\r\n                return true;\r\n            }\r\n            else {\r\n                return \"sem rompimento\";\r\n            }\r\n        }\r\n        else {\r\n            return \"sem resistência.\";\r\n        }\r\n\r\n\r\n\r\n        return bwMME;\r\n    };\r\n\r\n\r\n    self.setStopAndTarget  = function(candle,ifr){\r\n\r\n\r\n        //TODO: Talvez fosse bom limitar o ganho a 0.7% líquido, pra aumentar as chances de acertar. testar depois.\r\n        //o sistema sugeriu uma operação em G10 NATU3 ~10:40, com p:26,11, t:26:50 e s:25:91.\r\n        // Comprei por 25,94 e a ação chegou a valorizar 0,96% em ~15min.\r\n        //E a operação operação foi concluída com ganho em 26,40.\r\n\r\n\r\n\r\n        //TODO: colocar o limite de proxima resistencia tb.\r\n\r\n        //se o ifr ta abaixo de 10, stop mais baixo.\r\n\r\n        var stop = candle.min - 0.02;\r\n        var targetMultiplier = 2;//1.57;\r\n\r\n\r\n        var targetClose = candle.close + (targetMultiplier * (candle.close - stop));\r\n        var target = targetClose;//Number(Math.round(targetClose+'e2')+'e-2');\r\n\r\n\r\n        /*\r\n            if(ifr < 12)\r\n            stop -= 0.01; //aumenta em 1 centavo.\r\n        */\r\n\r\n        return {\r\n            stop: stop,\r\n            price: candle.close,\r\n            target: target\r\n            ///target_2: candle.close + (2 * (candle.close - stop))\r\n        }\r\n    };\r\n\r\n    self.mmeStrategyStopTarget = function(candleList) {\r\n\r\n      indicatorService.findTopsBottoms(candleList);\r\n\r\n      //var tops = indicatorService.tops.filter(function(top){}).sort(function(a,b){});\r\n\r\n\r\n\r\n      //stop = ultimo fundo abaixo do preço\r\n\r\n      //target = ultimo topo acima do preço.\r\n    };\r\n\r\n    self.mmeStrategy = function(candleList,verbose) {\r\n\r\n\r\n        //cruzamento pra cima após confirmação de tendencia de alta.\r\n        var tendecy = indicatorService.getActualTendency(candleList);\r\n\r\n        if(tendency.type !== indicatorService.tendencyType.BULLISH ){\r\n            if(verbose)\r\n                console.log(\"tendÊncia não é de alta.\");\r\n            return false;\r\n        }\r\n\r\n        //detecção de cruzamento\r\n        var lastIndex = candleList.length - 1;\r\n        var mme9 = indicatorService.MMEC(candleList,9);\r\n        var mme21 = indicatorService.MMEC(candleList,21);\r\n\r\n        for(var i = 4 ; i >= 0; i--) {\r\n            var currentIndex = lastIndex - i;\r\n            10\r\n            4,3,2,1,0\r\n            6,7,8,9,10\r\n\r\n            if(i > 2) { //negativos\r\n                if(mme9 > mme21) {\r\n                    if(verbose)\r\n                        console.log(\"não houve cruzamento.\");\r\n                    return false;\r\n                }\r\n            }\r\n            if(i < 2){ //positivos\r\n                if(mme9 < mme21) {\r\n                    if(verbose)\r\n                        console.log(\"não houve cruzamento.\");\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n\r\n    self.detectOpportunity = function(candleList,verbose,trenchs){\r\n\r\n        if(typeof verbose ===  'undefined'){\r\n            verbose = false;\r\n        }\r\n        //verbose = true;\r\n        //TODO: acho q fica melhor se botar os detectores em lógica fuzzy... ou algum peso. pq rompimento com força e volume grande pode n ser detectado por causa de médias móveis negativas.\r\n\r\n        if(candleList.length < 21) {\r\n            if(verbose)\r\n                console.log(\"candleList insuficiente.\");\r\n            return false;\r\n        }\r\n\r\n\r\n        //return self.mmeStrategy(candleList,verbose);\r\n\r\n\r\n\r\n\r\n        var lastIndex = candleList.length - 1;\r\n        var lastCandle = candleList[lastIndex];\r\n        //var beforeCandle = candleList[lastIndex - 1];\r\n        var resistenceCandle = candleList[lastIndex - 2];\r\n\r\n        if(typeof trenchs === 'undefined') {\r\n            indicatorService.findTrenchs(candleList);\r\n            trenchs = indicatorService.trenchs;\r\n        }\r\n\r\n        //ropendo a resistencia mais próxima ao candle anterior.\r\n        trenchs = trenchs.filter(function(trench){\r\n            return trench.value > resistenceCandle.close;\r\n        }).sort(function(a,b){\r\n            return a.value - b.value;\r\n        });\r\n\r\n\r\n\r\n\r\n\r\n        if(trenchs.length < 1){\r\n            if(verbose)\r\n                console.log(\"sem resistência próxima\");\r\n            return false;\r\n        }\r\n\r\n        if(lastCandle.open > trenchs[0].value) {\r\n            if(verbose)\r\n                console.log(\"sem rompimento de resistência.\");\r\n            return false;\r\n        }\r\n\r\n       // console.log(trenchs,lastCandle.open > trenchs[0].value);\r\n\r\n\r\n\r\n        if(lastCandle.isBearish()) {\r\n            if(verbose)\r\n                console.log(\"candle de rompimento não é de alta.\");\r\n            return false;\r\n        }\r\n\r\n\r\n        //com candle de força\r\n        //todo acho q pra ter certeza de q eh de força, seria bom ver se o corpo do candle é maior do que a média de alguns anteriores\r\n        if(!candleAnalysisService.detect_LONG_BODY(candleList)){\r\n            if(verbose)\r\n                console.log(\"candle não tem corpo longo\");\r\n            return false;\r\n        }\r\n\r\n\r\n\r\n        //com sem sompra superior longa (fechamento próximo da máxima.\r\n        //todo acho q pra ter certeza de q eh de força, seria bom ver se o corpo do candle é maior do que a média de alguns anteriores\r\n        if(candleAnalysisService.detect_LONG_SHADOW_UPPER(candleList)){\r\n            if(verbose)\r\n                console.log(\"candle tem sombra superior longa\");\r\n            return false;\r\n        }\r\n\r\n\r\n\r\n        ///bandas de bollinger contraidas.\r\n        var bw = indicatorService.bollingerWidth(candleList,20);\r\n        var bwMME = indicatorService.MMEIndicator(bw,20);\r\n\r\n\r\n\r\n        /*for(var i=0; i< 4; i++){\r\n            if(bwMME[lastIndex-i][0] < bwMME[lastIndex-(i+1)][0]) {\r\n                if(verbose)\r\n                    console.log(\"bandas de bollinger não se contraíndo. sem congestão.\");\r\n                return false;\r\n            }\r\n        }*/\r\n\r\n\r\n\r\n\r\n       /* if(!(bw[lastIndex][0]<bwMME[lastIndex][0])) {\r\n            if(verbose)\r\n                console.log(\"sem congestão.\",bw[lastIndex][0],bwMME[lastIndex][0]);\r\n            return false;\r\n        }*/\r\n\r\n\r\n        var bigestWidth = bw[candleList.length-1][0];\r\n        bw.forEach(function (width,i) {\r\n            var index = i;\r\n            //var index = (candleList.length-1)-i;\r\n           // console.log(bw[i][0],\"<\",bwMME[i][0],\"?\",bw[i][0]<bwMME[i][0]);\r\n            //console.log(index);\r\n            //if(index < candleList.length-61)\r\n            //    return;\r\n            //console.log(bw[index][0],bigestWidth);\r\n\r\n            bigestWidth = bw[index][0] > bigestWidth ? bw[index][0] : bigestWidth;\r\n        });\r\n        var congestionFactor = 0.25; //.25 = 100% ciel3 g10\r\n        if(bw[lastIndex][0] / bigestWidth > congestionFactor) {\r\n            if(verbose)\r\n                console.log(\"sem congestão.\",bw[lastIndex][0] / bigestWidth);\r\n            return false;\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n       /*\r\n       //está em  neutra ou alta.\r\n        var tendency = indicatorService.getActualTendency(candleList);\r\n        if(tendency.type != indicatorService.tendencyType.BULLISH) {\r\n            if(verbose)\r\n                console.log(\"tendencia não neutra nem de alta\");\r\n            return false;\r\n        }\r\n        */\r\n\r\n        //volume acima da media\r\n        var volumeRate = lastCandle.volume / indicatorService.volumeMMS(candleList,21)[lastIndex];\r\n        volumeRate -= 1;\r\n        if(volumeRate < 0.5) {\r\n            if(verbose)\r\n                console.log(\"volume não está acima da média.\");\r\n            return false;\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        //ifr menor que 90\r\n        if(indicatorService.IFR(candleList,2)[lastIndex] > 80) {\r\n            if(verbose)\r\n                console.log(\"ifr maior que 80. marcar pullback\");\r\n            return false;\r\n        }\r\n\r\n        var mme9 = indicatorService.MMEC(candleList,9);\r\n        var mme21 = indicatorService.MMEC(candleList,21);\r\n\r\n        //mme9 acima da mme21\r\n        if(mme9[lastIndex][0] <  mme21[lastIndex][0]) {\r\n            if(verbose)\r\n                console.log(\"mme9 < mme21\",mme9[lastIndex][0] - mme21[lastIndex][0]);\r\n            return false;\r\n        }\r\n\r\n\r\n        //mme's positivamente inclinadas //acho q eh mais pra medio prazo.\r\n        for(var i=0; i< 4; i++){\r\n            if(mme9[lastIndex-i][0] < mme9[lastIndex-(i+1)][0]) {\r\n                if(verbose)\r\n                    console.log(\"mme9 não inclinada positivamente\");\r\n                return false;\r\n            }\r\n            if(mme21[lastIndex-i][0] < mme21[lastIndex-(i+1)][0]) {\r\n                if(verbose)\r\n                    console.log(\"mme21 não inclinada positivamente\");\r\n                return false;\r\n            }\r\n        }\r\n\r\n        //console.error(volumeRate);\r\n        return true; //testar o nivel de acerto até aqui.\r\n\r\n        var boll = indicatorService.bollinger(candleList,20);\r\n        if(lastCandle.close > boll[lastIndex][1] + (((boll[lastIndex][0]-boll[lastIndex][1]) / 8)*7)){\r\n            if(verbose)\r\n                console.log(\"fechamento proximo à bollinger superior\");\r\n            return false;\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n        return true;\r\n\r\n\r\n    };\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    //stopLoss: minima do candle de oportunidade - 0,02 (cuidado com o papa stop);\r\n    //objetivo: 0,02 da proxima resistÊncia, até no máx preço de compra (fechamento) + (2*(candle.min - stop.loss))\r\n\r\n\r\n\r\n\r\n\r\n});","/**\r\n * Created by Ian on 06/01/2017.\r\n */\r\napp.service(\"strategyTestService\",function($http,candleAnalysisService,opportunityService,indicatorService) {\r\n    var self = this;\r\n\r\n\r\n    self.maxMemory = 5; //numero máximo de periodos q ele vai manter na memoria durante a detecção de padrões.\r\n\r\n\r\n\r\n\r\n    self.detectionTest = function(periods){\r\n        //self.maxPeriods = periods;\r\n\r\n        candleList = [];\r\n\r\n        var url = \"stock/\"+self.stock.code+\"/trades/\"+self.stock.start+\"/\"+self.stock.end+\"/\"+self.stock.periodLength+\"/\"+self.stock.maxPeriods;\r\n        var candleList = [];\r\n        console.info(\"Requisitando\",url);\r\n        $http.get(url).then(function(data){\r\n\r\n\r\n            console.info(\"Convertendo\",data.data.length,\"periodos.\");\r\n            data.data.forEach(function(element){\r\n                candleList.push(new Candle(\r\n                    element.start,\r\n                    element.end,\r\n                    element.min,\r\n                    element.open,\r\n                    element.close,\r\n                    element.max,\r\n                    element.quantity\r\n                ));\r\n            });\r\n            console.info(\"Pronto.\");\r\n\r\n\r\n\r\n\r\n            var detectedPatterns = {};\r\n\r\n            for( i = candleList.length-1; i >= 0 ; i--) {\r\n\r\n                var chunk = [];\r\n                var range = Math.min(self.maxMemory-1,i);\r\n\r\n\r\n                for(j = 0; j <= range; j++ ) {\r\n                    chunk.push(candleList[i-j]);\r\n                }\r\n\r\n                candleAnalysisService.detectAll(chunk).forEach(function(pattern){\r\n\r\n                    if(pattern[2]) {\r\n                        if(typeof detectedPatterns[pattern[1]] === 'undefined') {\r\n                            detectedPatterns[pattern[1]] = {\r\n                                detections: []\r\n                            }\r\n                        }\r\n                        detectedPatterns[pattern[1]].detections.push({\r\n                            index: i,\r\n                            //se future movement for positivo, houve alta.\r\n                            futureMovement: i < candleList.length-1 ? candleList[i+1].close - candleList[i].close : 0\r\n                        });\r\n                    }\r\n\r\n                });\r\n            }\r\n\r\n\r\n\r\n\r\n            var temp = [];\r\n\r\n\r\n            for (var key in detectedPatterns) {\r\n                temp.push({\r\n                    name: key,\r\n                    detections: detectedPatterns[key].detections\r\n                })\r\n            };\r\n\r\n            detectedPatterns = temp;\r\n\r\n\r\n\r\n            var analysis = [];\r\n            detectedPatterns.forEach(function(detectedPattern){\r\n                var precision = -1;\r\n                var match = 0;\r\n                var type = candleAnalysisService.candlePatterns[detectedPattern.name].type;\r\n\r\n                if(type === 1) {//bullish\r\n                    detectedPattern.detections.forEach(function (detection) {\r\n                        if(detection.futureMovement > 0)\r\n                            match++;\r\n                    });\r\n                }\r\n                else if(type === -1){ //bearish\r\n                    detectedPattern.detections.forEach(function (detection) {\r\n                        if(detection.futureMovement < 0)\r\n                            match++;\r\n                    });\r\n                }\r\n                precision =  match / detectedPattern.detections.length;\r\n\r\n\r\n                analysis.push({\r\n                    name: detectedPattern.name,\r\n                    times: detectedPattern.detections.length,\r\n                    precision: precision\r\n                });\r\n            });\r\n\r\n\r\n            analysis = analysis.sort(function(a,b){\r\n                return b.precision-a.precision;\r\n            });\r\n\r\n            analysis.forEach(function(detectedPattern){\r\n                console.log(detectedPattern.name,\":\",detectedPattern.times,'detections. --- Precision:', detectedPattern.precision);\r\n            });\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        },function(data){\r\n\r\n        });\r\n\r\n    };\r\n\r\n    self.getPreciseCandles = function(macroList,microList){\r\n        var macroIndex = macroList.length-1;\r\n        var microIndex = microList.length-1;\r\n        var macroDuration = macroList[macroIndex].timestamp - macroList[macroIndex-1].timestamp;\r\n        var microDuration = microList[microIndex].timestamp - microList[microIndex-1].timestamp;\r\n        equivalence = macroDuration / microDuration;\r\n\r\n        var lastTimestamp = macroList[macroIndex].timestamp;\r\n\r\n        return microList.filter(function(candle){\r\n            var match = candle.timestamp >= lastTimestamp && candle.timestamp < lastTimestamp + (60*(equivalence));\r\n            return match;\r\n        });\r\n    };\r\n\r\n    self.opportunityTest = function(ticker,periodLength,verbose,resultCallback,statusUpdateCallback) {\r\n\r\n        verbose = typeof verbose !== 'undefined' ? verbose : false;\r\n\r\n        var macroPeriodLength;\r\n        switch(periodLength){\r\n            default: macroPeriodLength = 60; break;\r\n            case 1: macroPeriodLength = 5; break;\r\n            case 5: macroPeriodLength = 15; break;\r\n            //case 10: macroPeriodLength = 30; break;\r\n           // case 15: macroPeriodLength = 60; break;\r\n        }\r\n\r\n        var bullOne = this;\r\n        bullOne.test = function(ticker,periodLength,verbose,resultCallback,statusUpdateCallback) {\r\n\r\n            var url = \"stock/\"+ticker+\"/trades/2000-01-01-00-00/2020-01-01-00-00/1/0\";\r\n            minuteCandleList = [];\r\n\r\n\r\n            if(typeof statusUpdateCallback !== 'undefined')\r\n                statusUpdateCallback(\"Inicializando...\");\r\n\r\n\r\n            if(verbose)console.info(\"Obtendo limite histórico...\");\r\n            $http.get(url).then(function(data){\r\n\r\n                if(data.data.length <1) {\r\n                    console.error(\"não foi possivel obter o limite histórico. Limite Histórico.\",url);\r\n                    return;\r\n                }\r\n\r\n                data.data[0].start = data.data[0].start.replace(\" \", \"-\").replace(\":\", \"-\");\r\n                data.data[0].start = data.data[0].start.split(\"-\");\r\n                apiLimitDate = new Date(data.data[0].start[0],data.data[0].start[1],data.data[0].start[2],data.data[0].start[3],data.data[0].start[4],0,0);\r\n                //console.info(\"Limite histórico para\",ticker+\":\", apiLimitDate);\r\n\r\n                data.data.forEach(function(element,ei){\r\n\r\n                    var start;\r\n                    if(ei > 0) {\r\n                        start = element.start.replace(\" \", \"-\").replace(\":\", \"-\").replace(\":\", \"-\").split(\"-\");\r\n                    }\r\n                    else {\r\n                        start = element.start;\r\n                    }\r\n\r\n                    // start = (new Date(start[0],start[1],start[2],start[3],start[4],0,0)).getTime()/1000;\r\n\r\n                    //element.timestamp = (new Date(start[0],start[1],start[2],start[3],start[4],0,0)).getTime()/1000;\r\n                    var candle = new Candle(\r\n                        start.join(\"-\"),\r\n                        element.end,\r\n                        element.min,\r\n                        element.open,\r\n                        element.close,\r\n                        element.max,\r\n                        element.quantity,\r\n                        element.timestamp\r\n                    );\r\n                    minuteCandleList.push(candle);\r\n                });\r\n\r\n\r\n                var url = \"stock/\"+ticker+\"/trades/\"+minuteCandleList[0].start+\"/2020-01-01-00-00/\"+macroPeriodLength+\"/0\";\r\n                macroCandleList = [];\r\n                if(typeof statusUpdateCallback !== 'undefined')\r\n                    statusUpdateCallback(\"Obtendo macroperíodos(\"+macroPeriodLength+\")...\");\r\n\r\n                if(verbose)console.info(\"Obtendo macroperíodos(\"+macroPeriodLength+\")...\");\r\n                $http.get(url).then(function(data) {\r\n                    data.data.forEach(function (element) {\r\n\r\n                        var start = element.start.replace(\" \", \"-\")\r\n                        //.replace(\":\", \"-\");\r\n                            .replace(\":\", \"-\");\r\n\r\n                        var candle = new Candle(\r\n                            start,\r\n                            element.end,\r\n                            element.min,\r\n                            element.open,\r\n                            element.close,\r\n                            element.max,\r\n                            element.quantity,\r\n                            element.timestamp\r\n                        );\r\n                        macroCandleList.push(candle);\r\n                    });\r\n                    if (verbose) console.info(\"Pronto.\");\r\n\r\n                    url = \"stock/\"+ticker+\"/trades/\"+minuteCandleList[0].start+\"/2020-01-01-00-00/\"+periodLength+\"/0\";\r\n                    var candleList = [];\r\n\r\n\r\n                    if(typeof statusUpdateCallback !== 'undefined')\r\n                        statusUpdateCallback(\"Requisitando dados...\");\r\n\r\n\r\n                    if(verbose)console.info(\"Requisitando\",url);\r\n                    $http.get(url).then(function(data) {\r\n\r\n                        //if(typeof statusUpdateCallback !== 'undefined')\r\n                            statusUpdateCallback(\"Processando Períodos...\");\r\n\r\n\r\n                        if (verbose) console.info(\"Convertendo\", data.data.length, \"periodos.\");\r\n                        data.data.forEach(function (element) {\r\n\r\n                            var start = element.start.replace(\" \", \"-\")\r\n                            //.replace(\":\", \"-\");\r\n                                .replace(\":\", \"-\");\r\n\r\n                            var candle = new Candle(\r\n                                start,\r\n                                element.end,\r\n                                element.min,\r\n                                element.open,\r\n                                element.close,\r\n                                element.max,\r\n                                element.quantity,\r\n                                element.timestamp\r\n                            );\r\n                            candleList.push(candle);\r\n                        });\r\n                        if (verbose) console.info(\"Pronto.\");\r\n\r\n\r\n                        indicatorService.findTrenchs(candleList);\r\n\r\n\r\n\r\n                        operations = [];\r\n                        var opportunityFound;\r\n                        for (i = 20; i < candleList.length; i++) {\r\n\r\n\r\n\r\n                            //separar os macroChunks.\r\n                            var chunk = [];\r\n                            for (j = 0; j <= i; j++) {\r\n                                chunk.push(candleList[j]);\r\n                            }\r\n\r\n                            var preciseLast = self.getPreciseCandles(chunk,minuteCandleList);\r\n                            if(preciseLast.length === 0)\r\n                                continue;\r\n                            //console.log(preciseLast);\r\n\r\n                            //tirando o ultimo elemento.\r\n\r\n\r\n                            var lastCandle = new Candle(\r\n                                preciseLast[0].start,\r\n                                preciseLast[0].end,\r\n                                1000000000,\r\n                                preciseLast[0].open,\r\n                                0,\r\n                                0,\r\n                                0,\r\n                                preciseLast[0].timestamp\r\n                            );\r\n                            opportunityFound = false;\r\n\r\n                            do {\r\n                                chunk.pop();\r\n\r\n                                lastCandle.end =  preciseLast[0].end;\r\n                                lastCandle.start =  preciseLast[0].start;\r\n                                lastCandle.close =  preciseLast[0].close;\r\n                                lastCandle.volume +=  preciseLast[0].volume;\r\n                                lastCandle.timestamp =  preciseLast[0].timestamp;\r\n                                lastCandle.min =  preciseLast[0].min <  lastCandle.min ? preciseLast[0].min : lastCandle.min;\r\n                                lastCandle.max =  preciseLast[0].max >  lastCandle.max ? preciseLast[0].max : lastCandle.max;\r\n                                lastCandle.max =  preciseLast[0].max >  lastCandle.max ? preciseLast[0].max : lastCandle.max;\r\n\r\n                                preciseLast.shift();\r\n\r\n                                chunk.push(lastCandle);\r\n\r\n\r\n\r\n                                //fazer os testes com a candleList agora.\r\n                                if(opportunityService.detectOpportunity(chunk,verbose,indicatorService.trenchs)) {\r\n\r\n\r\n\r\n                                    //se já tiver adicionado para este chunk, continua.\r\n\r\n                                    if(opportunityFound) {\r\n                                        //console.log(\"achou\");\r\n                                        continue;\r\n                                    }\r\n\r\n\r\n//TODO: Colocar todo comportamento de filtragem de oportunidade em uma função q reflita a estratégia.\r\n                                    //verificação do macroPeriodo.\r\n                                    var macroPeriodIndex = macroCandleList.findIndex(function(auxCandle){\r\n                                        return auxCandle.timestamp > chunk[i].timestamp;\r\n                                    });\r\n                                    macroPeriodIndex--;\r\n\r\n                                    if(macroPeriodIndex < 0) {\r\n                                        console.log(\"erro G\"+macroPeriodLength,macroPeriodIndex);\r\n                                        continue;\r\n                                    }\r\n\r\n\r\n                                    var chunk3 = [];\r\n                                    for(j = 0; j <= macroPeriodIndex; j++) {\r\n                                        chunk3.push(macroCandleList[j]);\r\n                                    }\r\n\r\n                                    var macroTendency = indicatorService.getActualTendency(chunk3).type;\r\n\r\n\r\n                                    if(macroTendency === indicatorService.tendencyType.BEARISH) {\r\n                                        if(verbose) console.log(\"Tendência G\"+macroPeriodLength+\" de baixa. \");\r\n                                        continue;\r\n                                    }\r\n\r\n\r\n                                    var st = chunk[i].start.split(\"-\");\r\n                                    var startDate = (new Date(st[0],st[1]-1,st[2],st[3],st[3],0,0)).getTime();\r\n                                    var buyLimit = (new Date(st[0],st[1]-1,st[2],17,0,0,0)).getTime();\r\n\r\n                                    if(startDate >= buyLimit) { //limite de operação dayTrade.\r\n                                        if(verbose) console.log(\"Limite de operação daytrade atingido.\");\r\n                                        continue;\r\n                                    }\r\n\r\n                                    var ifr = indicatorService.IFR(chunk,2)[i][0];\r\n                                    operation = opportunityService.setStopAndTarget(chunk[i],ifr);\r\n\r\n                                    if(operation.target === operation.stop) { //diferença insuficiente.\r\n                                        continue;\r\n                                    }\r\n\r\n\r\n////////////////\r\n\r\n                                    opportunityFound = true;\r\n\r\n                                    if(verbose)console.log(\"ADD\",i,operation);\r\n                                    operation.index = i;\r\n                                    operation.start = \"\" + chunk[i].start;\r\n                                    operation.ticker = ticker;\r\n                                    operation.limitDate = false;\r\n                                    operation.timestamp = parseInt(chunk[i].timestamp);\r\n                                    operations.push(operation);\r\n                                    //capital -= 10000;\r\n                                }\r\n\r\n\r\n\r\n                            }while(preciseLast.length > 0 && !opportunityFound);\r\n\r\n                        }\r\n\r\n\r\n                        //depois de achar as oportunidades, resolvê-las.\r\n                        var gain = 0;\r\n                        var loss =0;\r\n                        var accumGain = 1;\r\n                        var accumLoss = 1;\r\n                        var accumTotal = 1;\r\n                        var first = 0;\r\n                        var last = 0;\r\n\r\n                        if(typeof statusUpdateCallback !== 'undefined')\r\n                            statusUpdateCallback(\"Processando Oportunidades...\");\r\n                        operations.forEach(function (operation,oi) {\r\n                            if(oi === 0) {\r\n                                first = operation.start;\r\n                            }\r\n                            last = operation.start;\r\n                           var result = self.completeOperation(operation,candleList,oi,verbose,minuteCandleList);\r\n\r\n                           if(result > 0) {\r\n                               gain++;\r\n                               accumGain *= 1 + result;\r\n\r\n                           }\r\n                           else {\r\n                               loss++;\r\n                               accumLoss *= 1 + (result * -1);\r\n                           }\r\n                            accumTotal *= 1 + result;\r\n                        });\r\n\r\n                        accumGain -= 1;\r\n                        accumGain *= 100;\r\n                        accumLoss -= 1;\r\n                        accumLoss *= 100;\r\n                        accumTotal -= 1;\r\n                        accumTotal *= 100;\r\n\r\n\r\n                        if(typeof resultCallback !== \"undefined\") {\r\n                            resultCallback(ticker,{\r\n                                first : \"\" + first,\r\n                                last :  \"\" + last,\r\n                                gain : parseInt(gain),\r\n                                loss : parseInt(loss),\r\n                                accGain : parseFloat(accumGain.toFixed(2)),\r\n                                accLoss : parseFloat(accumLoss.toFixed(2)),\r\n                                accTotal : parseFloat(accumTotal.toFixed(2)),\r\n                                operations: operations\r\n                            });\r\n                        }\r\n                    },function(data){\r\n                       bullOne.test(ticker,periodLength,verbose,resultCallback,statusUpdateCallback);\r\n                    })\r\n                },function(data){\r\n                    bullOne.test(ticker,periodLength,verbose,resultCallback,statusUpdateCallback);\r\n                })\r\n            },function(data){\r\n                bullOne.test(ticker,periodLength,verbose,resultCallback,statusUpdateCallback);\r\n            });\r\n        };\r\n        bullOne.test(ticker,periodLength,verbose,resultCallback,statusUpdateCallback);\r\n    };\r\n\r\n    self.completeOperation = function (operation,candleList,oi,verbose,minuteCandleList){\r\n\r\n\r\n\r\n\r\n        //var operationStartTimestamp = operation.start.split(\"-\");\r\n        //operationStartTimestamp = (new Date(operationStartTimestamp[0],operationStartTimestamp[1],operationStartTimestamp[2],operationStartTimestamp[3],operationStartTimestamp[4],0,0)).getTime()/1000;\r\n        //console.log(operation);\r\n\r\n        var currentCandles = minuteCandleList.filter(function(candle){\r\n            return candle.timestamp > operation.timestamp;\r\n        });\r\n        //console.log(currentCandles);\r\n        //return;\r\n\r\n\r\n\r\n        //currentCandles.shift(); //removendo o primeiro, pq eh o candle de abertura.\r\n\r\n        if( currentCandles.length < 1) {\r\n            console.log(\"candlelist vazia: erro:\",oi);\r\n            //self.completeOperation(operation,candleList,oi);\r\n        }\r\n\r\n\r\n        else {\r\n\r\n            var incomplete = true;\r\n            var operationDate = operation.start.split(\"-\");\r\n            //operationDate = new Date(operationDate[0],operationDate[1],operationDate[2],operationDate[3],operationDate[4],0,0);\r\n            var currentIndex = 0;\r\n            while(incomplete && currentIndex < currentCandles.length){\r\n                var candle = currentCandles[currentIndex];\r\n                currentIndex++;\r\n\r\n\r\n                //console.log(\"ok\",operation.target <= candle.max,candle.min < operation.stop);\r\n\r\n\r\n\r\n                //ajuste para evitar erro por gap nas datas.\r\n\r\n\r\n                if(operation.target <= candle.max) { //GAIN\r\n\r\n                    tax = (operation.target / operation.price)-1;\r\n                    if(verbose)console.warn('GAIN ----',oi);\r\n                    if(verbose)console.info({s:operation.stop,t:operation.target,p:operation.price,time: candleList[operation.index].start});\r\n                    if(verbose)console.info(candleList[operation.index].start);\r\n                    if(verbose)console.info(candle.start);\r\n\r\n                    operation.end =  candle.start;\r\n                    operation.result =  true;\r\n                    //operation.url =  \"\"+url;\r\n\r\n\r\n                    incomplete = false;\r\n                    //complete = true;\r\n                    continue;\r\n                }\r\n                else if(candle.min < operation.stop) { //loss\r\n                    tax = (1 - (operation.stop / operation.price)) * -1;\r\n                    if(verbose)console.error('LOSS ----',oi);\r\n                    if(verbose)console.info({s:operation.stop,t:operation.target,p:operation.price,time: candleList[operation.index].start});\r\n                    if(verbose)console.info(candleList[operation.index].start);\r\n                    if(verbose)console.info(candle.start,candle.min);\r\n\r\n                    operation.end =  candle.start;\r\n                    operation.result =  false;\r\n\r\n                    incomplete = false;\r\n                    //complete = true;\r\n                    continue;\r\n                }\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n            //console.log(operation,incomplete,currentIndex,candleList[operation.complete]);\r\n\r\n\r\n            if(incomplete && operation.limitDate) {\r\n                console.error(currentCandles.length, oi, 'EEEEEEEEEEEEEEEEEEEND' );\r\n            }\r\n            if(!incomplete) {\r\n                    return tax;\r\n            }\r\n            return 0;\r\n        }\r\n    };\r\n\r\n\r\n});","/**\r\n * Created by Ian on 29/12/2016.\r\n */\r\napp.controller(\"candleController\",function($scope,$http,indicatorService,candleAnalysisService,strategyTestService,opportunityService,$window,$interval){\r\n\r\n\r\n    //http://stockbot.app/stock/PETR4/trades/2015-07-02-13-45-00/2015-07-02-16-18-00/5/2000\r\n    $scope.stock = {\r\n        code : 'PETR4',\r\n        start :'2017-01-06 10:15',\r\n        end :'2017-01-06 17:30',\r\n        periodLength : 10,\r\n        maxPeriods : 0\r\n    };\r\n\r\n\r\n    $scope.renkoResolution = 3;\r\n\r\n\r\n\r\n\r\n\r\n    var IBrX50 = [\r\n        \"ABEV3\",\"BBAS3\",\"BBDC3\",\"BBDC4\",\"BBSE3\",\r\n        \"BRFS3\",\"BRKM5\",\"BRML3\",\"BVMF3\",\"CCRO3\",\r\n        \"CIEL3\",\"CMIG4\",\"CPFE3\",\"CSAN3\",\"CSNA3\",\r\n        \"CTIP3\",\"EGIE3\",\"EMBR3\",\"ENBR3\",\"EQTL3\",\r\n        \"ESTC3\",\"FIBR3\",\"GGBR4\",\"GOAU4\",\"HYPE3\",\r\n        \"ITSA4\",\"ITUB4\",\"JBSS3\",\"KLBN11\",\"KROT3\",\r\n        \"LAME4\",\"LREN3\",\"MRVE3\",\"MULT3\",\"NATU3\",\r\n        \"PCAR4\",\"PETR3\",\"PETR4\",\"QUAL3\",\"RADL3\",\r\n        \"RENT3\",\"RUMO3\",\"SBSP3\",\"SUZB5\",\"UGPA3\",\r\n        \"USIM5\",\"VALE3\",\"VALE5\",\"VIVT4\",\"WEGE3\"\r\n    ];\r\n\r\n    var IBrX100 = [\r\n        \"ABEV3\",\"ALPA4\",\"ALSC3\",\"ALUP11\",\"BBAS3\",\r\n        \"BBDC3\",\"BBDC4\",\"BBSE3\",\"BEEF3\",\"BRAP4\",\r\n        \"BRFS3\",\"BRKM5\",\"BRML3\",\"BRPR3\",\"BRSR6\",\r\n        \"BTOW3\",\"BVMF3\",\"CCRO3\",\"CESP6\",\"CIEL3\",\r\n        \"CMIG4\",\"CPFE3\",\"CPLE6\",\"CSAN3\",\"CSMG3\",\r\n        \"CSNA3\",\"CTIP3\",\"CVCB3\",\"CYRE3\",\"DTEX3\",\r\n        \"ECOR3\",\"EGIE3\",\"ELET3\",\"ELET6\",\"ELPL4\",\r\n        \"EMBR3\",\"ENBR3\",\"EQTL3\",\"ESTC3\",\"EZTC3\",\r\n        \"FIBR3\",\"FLRY3\",\"GFSA3\",\"GGBR4\",\"GOAU4\",\r\n        \"GOLL4\",\"HGTX3\",\"HYPE3\",\"IGTA3\",\"ITSA4\",\r\n        \"ITUB4\",\"JBSS3\",\"KLBN11\",\"KROT3\",\"LAME3\",\r\n        \"LAME4\",\"LEVE3\",\"LIGT3\",\"LREN3\",\"MDIA3\",\r\n        \"MGLU3\",\"MPLU3\",\"MRFG3\",\"MRVE3\",\"MULT3\",\r\n        \"MYPK3\",\"NATU3\",\"ODPV3\",\"PCAR4\",\"PETR3\",\r\n        \"PETR4\",\"POMO4\",\"PSSA3\",\"QGEP3\",\"QUAL3\",\r\n        \"RADL3\",\"RAPT4\",\"RENT3\",\"RUMO3\",\"SANB11\",\r\n        \"SBSP3\",\"SEER3\",\"SMLE3\",\"SMTO3\",\"SULA11\",\r\n        \"SUZB5\",\"TAEE11\",\"TIET11\",\"TIMP3\",\"TOTS3\",\r\n        \"TRPL4\",\"TUPY3\",\"UGPA3\",\"USIM5\",\"VALE3\",\r\n        \"VALE5\",\"VIVT4\",\"VLID3\",\"VVAR11\",\"WEGE3\"\r\n    ];\r\n\r\n\r\n\r\n\r\n\r\n    $scope.stockWatchList = [\r\n        \"NATU3\",\"BBSE3\",\"VALE5\",\"RUMO3\",\"CSAN3\",\r\n        \"CSNA3\",\"CMIG4\",\"RENT3\",\"QUAL3\",\"CCRO3\",\r\n        \"ITSA4\",\"MRVE3\",\"JBSS3\",\"GOAU4\",\"USIM5\",\r\n        \"CIEL3\",\"MULT3\",\"BBDC3\",\"SBSP3\",\"ABEV3\",\r\n        \"BRKM5\",\"ENBR3\",\"EMBR3\",\"VIVT3\"\r\n    ];\r\n\r\n    $scope.stockWatchList = IBrX100; //pra fins de teste\r\n\r\n\r\n    $scope.stockWatchs = [];\r\n    $scope.stockWatchList.forEach(function(ticker){\r\n        $scope.stockWatchs.push({\r\n            index: $scope.stockWatchs.length,\r\n            ticker:ticker,\r\n            operations: [],\r\n            operationsNum : 0,\r\n            first:0,\r\n            last:0,\r\n            gain:0,\r\n            gainP:0,\r\n            loss:0,\r\n            lossP:0,\r\n            accGain:0,\r\n            accLoss:0,\r\n            accTotal: 0\r\n        });\r\n    });\r\n\r\n    var d = new Date();\r\n    if(d.getHours() < 9)\r\n        d.setDate(d.getDate()-1);\r\n    if(d.getDate() < 1)\r\n        d.setMonth(d.getMonth()-1);\r\n\r\n    var day = (\"00\" + d.getDate()).slice(-2);\r\n    var month = (\"00\" + (d.getMonth()+1)).slice(-2);\r\n    $scope.stock.start = d.getFullYear() + \"-\" + month + \"-\" + day + \" 07:00\";\r\n    $scope.stock.end = d.getFullYear() + \"-\" + month + \"-\" + day + \" 20:00\";\r\n\r\n\r\n\r\n    $scope.selectedAnalysis = function() {\r\n        var maxIndex =  $scope.candleList.length -1;\r\n        if(typeof selected !== 'undefined') {\r\n            maxIndex = selected.row;\r\n        }\r\n        var chunk = [];\r\n        for(var i = 0; i <= maxIndex; i++)\r\n            chunk.push($scope.candleList[i])\r\n\r\n        //console.log(chunk.length);\r\n\r\n       console.log(\"------reconhecendo...\");\r\n       var detected = false;\r\n       candleAnalysisService.detectAll(chunk).forEach(function(result){\r\n           if(result[2]) {\r\n               console.log(result[1]);\r\n               detected = true;\r\n           }\r\n       });\r\n       if(!detected)\r\n           console.log(\"Sem padrões reconhecidos.\");\r\n\r\n\r\n\r\n    };\r\n\r\n    $scope.resultList = [];\r\n    $scope.cancelChecks;\r\n    $scope.applyOnList = function(){\r\n\r\n        if(typeof $scope.cancelChecks !== 'undefined'){\r\n            $interval.cancel($scope.cancelChecks)\r\n        }\r\n\r\n        $scope.cancelChecks = $interval($scope.applyOnList,61000);\r\n        console.log(\"executando checagem de oportunidade.\",new Date());\r\n\r\n\r\n        var audio = new Audio('alert1.mp3');\r\n\r\n\r\n        $scope.stockWatchs.forEach(function(stock){\r\n            stock.operationsNum = 0;\r\n        });\r\n\r\n\r\n\r\n        $scope.resultList = [];\r\n       opportunityService.applyOnList(opportunityService.detectOpportunity ,$scope.stockWatchs,$scope.stock.periodLength,function(ticker,result,lastCandle,target){\r\n            //$scope.resultList = [];\r\n            $scope.resultList.push({ticker: ticker, result:result,target:target, lastCandle:lastCandle});\r\n\r\n\r\n           $stock = $scope.stockWatchs[$scope.stockWatchs.findIndex(function(stock){\r\n                return stock.ticker === ticker;\r\n            })];\r\n           //$stock.operationsNum = result ? 0 : result;\r\n           $stock.last = lastCandle.end;\r\n           $stock.first = lastCandle.exchange;\r\n\r\n           if(result === true) {\r\n\r\n\r\n\r\n\r\n\r\n\r\n               //TODO: Quando multiplas estratégias forem utiilzadas, mostrar também ql estratégia achou a oportunidade\r\n               // e calcular ql é a confiabilidade/performance da estratégia praquela ação específica.\r\n\r\n\r\n               console.warn(\"found: \", ticker,target);\r\n               audio.play();\r\n           }\r\n\r\n\r\n\r\n            if($scope.resultList.length === $scope.stockWatchs.length) {\r\n\r\n\r\n               ///registrar as operaçoes encontradas\r\n\r\n\r\n                $scope.resultList.forEach(function(result){\r\n\r\n                    if(result.result === false) //o && false é DEBUG\r\n                        return;\r\n\r\n                    /*if(typeof result.target === 'undefined'){ //DEBUG\r\n                        result.target = {\r\n                            price:result.ticker,\r\n                            target:0,\r\n                            stop:0\r\n                        }\r\n                    }*/\r\n\r\n                    var stock = $scope.stockWatchs[$scope.stockWatchs.findIndex(function(stock){\r\n                        return stock.ticker === result.ticker;\r\n                    })];\r\n\r\n                    stock.operations.push({\r\n                        stop: result.target.stop,\r\n                        price: result.target.price,\r\n                        target: result.target.target,\r\n                        start : result.lastCandle.start,\r\n                        ticker : result.ticker,\r\n                        limitDate : false,\r\n                        timestamp : result.lastCandle.timestamp\r\n                    });\r\n\r\n                    stock.operationsNum = stock.operations.length;\r\n\r\n                    var  url = \"stock/operation\";\r\n                    var data = {\r\n                        ticker: result.ticker,\r\n                        timestamp: result.lastCandle.timestamp, //TODO esse tempo aqui tem q ser o tempo q a oportunnidade foi achada, n o tempo do periodo.\r\n                        price: result.target.price,\r\n                        stop: result.target.stop,\r\n                        target: result.target.target,\r\n                        type: \"c\",\r\n                        periodLength: $scope.stock.periodLength\r\n                    };\r\n\r\n                    this.send = function () {\r\n                        $http.post(url, data).then(\r\n                            function (data) {\r\n\r\n                            },\r\n                            function (data) {\r\n                                this.send();\r\n                            }\r\n                        );\r\n                    };\r\n                    this.send();\r\n                });\r\n\r\n                $scope.resultList = [];\r\n\r\n            }\r\n       });\r\n    };\r\n\r\n    $scope.getActualTendency = function() {\r\n\r\n        $scope.actualTendency = indicatorService.getActualTendency($scope.candleList).type;\r\n        console.log($scope.actualTendency)\r\n    };\r\n\r\n    $scope.opportunityList = function(){\r\n\r\n    };\r\n\r\n\r\n    $scope.detectionTest = function(ticker) {\r\n\r\n        console.log(ticker);\r\n\r\n        var currentWatch;\r\n        if(typeof ticker === \"undefined\" ) {\r\n            currentWatch = 0;\r\n        }\r\n\r\n\r\n        $scope.stockWatchs.forEach(function(stock,i){\r\n            if(typeof ticker !== \"undefined\" && ticker !== stock.ticker ) {\r\n                return;\r\n            }\r\n            if(typeof ticker !== \"undefined\" && ticker === stock.ticker ) {\r\n                currentWatch = i;\r\n            }\r\n\r\n            stock.operations= [];\r\n            stock.operationsNum = 0;\r\n            stock.first=0;\r\n            stock.last=0;\r\n            stock.gain=0;\r\n            stock.gainP=0;\r\n            stock.loss=0;\r\n            stock.lossP=0;\r\n            stock.accGain=0;\r\n            stock.accLoss=0;\r\n            stock.accTotal= 0;\r\n        });\r\n\r\n\r\n        var completeTest = function(tick,results){\r\n\r\n\r\n            var stock = $scope.stockWatchs.find(function(stock){\r\n                return stock.ticker === tick;\r\n            });\r\n\r\n            stock.operations = results.operations;\r\n            stock.operationsNum = stock.operations.length;\r\n            stock.first = \"\" + results.first;\r\n            stock.last = \"\" + results.last;\r\n            stock.gain = \"\" + results.gain;\r\n            stock.gainP = stock.operationsNum > 0 ? ((results.gain * 100) /  stock.operationsNum).toFixed(2) : 0;\r\n            stock.loss = \"\" + results.loss;\r\n            stock.lossP = stock.operationsNum > 0 ?  ((results.loss * 100) /  stock.operationsNum).toFixed(2) : 0;\r\n            stock.accGain = \"\" + results.accGain;\r\n            stock.accLoss = \"\" + results.accLoss;\r\n            stock.accTotal = \"\" + results.accTotal;\r\n\r\n            currentWatch++;\r\n            if(typeof ticker === 'undefined' && currentWatch < $scope.stockWatchs.length) {\r\n                strategyTestService.opportunityTest ( $scope.stockWatchs[currentWatch].ticker,$scope.stock.periodLength,typeof ticker !== \"undefined\",completeTest,statusUpdate);\r\n            }\r\n\r\n            $scope.stockWatcherAll = {\r\n                operationsNum:0,\r\n                gain : 0,\r\n                loss : 0,\r\n                accGain : 1,\r\n                accLoss : 1,\r\n                accTotal : 1\r\n            };\r\n\r\n            $scope.stockWatchs.forEach(function(stock){\r\n\r\n\r\n                $scope.stockWatcherAll.operationsNum += parseInt(stock.operationsNum);\r\n                $scope.stockWatcherAll.gain += parseInt(stock.gain);\r\n                $scope.stockWatcherAll.loss += parseInt(stock.loss);\r\n                $scope.stockWatcherAll.accGain *= parseFloat(1 + (stock.accGain/100));\r\n                $scope.stockWatcherAll.accLoss *= parseFloat(1 + (stock.accLoss/100));\r\n                $scope.stockWatcherAll.accTotal *= parseFloat(1 + (stock.accTotal/100));\r\n            });\r\n\r\n            $scope.stockWatcherAll.gainP = (($scope.stockWatcherAll.gain * 100) /  $scope.stockWatcherAll.operationsNum).toFixed(2);\r\n            $scope.stockWatcherAll.lossP = (($scope.stockWatcherAll.loss * 100) /  $scope.stockWatcherAll.operationsNum).toFixed(2);\r\n            $scope.stockWatcherAll.accGain = (($scope.stockWatcherAll.accGain - 1) * 100).toFixed(2);\r\n            $scope.stockWatcherAll.accLoss = (($scope.stockWatcherAll.accLoss - 1) * 100).toFixed(2);\r\n            $scope.stockWatcherAll.accTotal = (($scope.stockWatcherAll.accTotal - 1) * 100).toFixed(2);\r\n\r\n        };\r\n\r\n\r\n        var statusUpdate = function(message) {\r\n            $scope.stockWatchs[currentWatch].first = message;\r\n        };\r\n\r\n        strategyTestService.opportunityTest ( $scope.stockWatchs[currentWatch].ticker,$scope.stock.periodLength,typeof ticker !== \"undefined\",completeTest,statusUpdate);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    };\r\n\r\n    $scope.testTableSort = function(collum) {\r\n        this.invert = this.lastCollum === collum ? !(this.invert) : false;\r\n        var self = this;\r\n        $scope.stockWatchs = $scope.stockWatchs.sort(function(a,b){\r\n            var aValue = (\"\"+a[collum]).split('-');\r\n            if(aValue.length === 5) {\r\n                aValue = (new Date(aValue[0],aValue[1],aValue[2],aValue[3],aValue[4],0,0)).getTime();\r\n\r\n            }\r\n            else {\r\n                aValue =  a[collum];\r\n            }\r\n            var bValue = (\"\"+b[collum]).split('-');\r\n            if(bValue.length === 5) {\r\n                bValue = (new Date(bValue[0],bValue[1],bValue[2],bValue[3],bValue[4],0,0)).getTime();\r\n\r\n            }\r\n            else {\r\n                bValue =  b[collum];\r\n            }\r\n\r\n\r\n            if(self.invert)\r\n                return aValue - bValue;\r\n            else\r\n                return bValue - aValue;\r\n\r\n        });\r\n        this.lastCollum = collum;\r\n    };\r\n\r\n\r\n    $scope.showInterval= function(start,end,ticker){\r\n        st = start.split(\"-\");\r\n        ed = end.split(\"-\");\r\n\r\n        //voltando alguns periodos.\r\n\r\n\r\n\r\n        var ajuste = parseInt(st[4]) % parseInt($scope.stock.periodLength);\r\n        ajuste = parseInt(st[4])  - ajuste;\r\n\r\n        startDate = new Date(st[0],st[1]-1,st[2],st[3],ajuste,0,0);\r\n        realStartDate = new Date(st[0],st[1]-1,st[2],st[3],ajuste,0,0);\r\n        //console.log(st,startDate);\r\n        for(i = 0; i < 35; i++) {\r\n            startDate.setTime(startDate.getTime()-(60000*$scope.stock.periodLength));\r\n\r\n            if(startDate.getHours() < 9){\r\n                startDate.setHours(17);\r\n                startDate.setMinutes(30);\r\n                startDate.setTime(startDate.getTime()-(86400000));\r\n            }\r\n\r\n            if(startDate.getDay() === 0 || startDate.getDay() === 6)\r\n                i--;\r\n        }\r\n\r\n        var onth = \"\" + (startDate.getMonth()+1);\r\n        var ate = \"\" + startDate.getDate();\r\n        var ours = \"\" + startDate.getHours();\r\n        var inutes = \"\" + startDate.getMinutes();\r\n        \r\n        st = [\r\n            startDate.getFullYear(),\r\n            (\"00\").substring(0, 2 - onth.length) + onth,\r\n            (\"00\").substring(0, 2 - ate.length) + ate,\r\n            (\"00\").substring(0, 2 - ours.length) + ours,\r\n            (\"00\").substring(0, 2 - inutes.length) + inutes\r\n        ];\r\n\r\n        $scope.stock.start = st[0] + \"-\" + st[1] + \"-\" +st[2] + \" \" + st[3] + \":\" + st[4];\r\n        $scope.stock.end= ed[0] + \"-\" + ed[1] + \"-\" +ed[2] + \" \" + ed[3] + \":\" + ed[4];\r\n\r\n        $scope.stock.code = ticker;\r\n\r\n        $scope.updateCharts(realStartDate/1000);\r\n\r\n    };\r\n\r\n    $scope.candleList = [];\r\n    $scope.updateCharts = function(selectDate) {\r\n\r\n        $window.document.title = $scope.stock.code + \" - stockBot\"\r\n        candleList = [];\r\n        debug = [];\r\n        //console.log($scope.chart);\r\n\r\n\r\n        searchStart = $scope.stock.start.replace(\" \", \"-\")\r\n            //.replace(\":\", \"-\")\r\n            .replace(\":\", \"-\");\r\n        searchEnd = $scope.stock.end.replace(\" \", \"-\")\r\n            //.replace(\":\", \"-\")\r\n            .replace(\":\", \"-\");\r\n\r\n\r\n        var url = \"stock/\"+$scope.stock.code+\"/trades/\"+searchStart +\"/\"+searchEnd+\"/\"+$scope.stock.periodLength+\"/\"+$scope.stock.maxPeriods;\r\n        var candleList = [];\r\n\r\n        $http.get(url).then(function(data){\r\n\r\n            if(data.data.length > 0)\r\n                $scope.firstCandle = data.data[0];\r\n\r\n            data.data.forEach(function(element){\r\n                var candle = new Candle(\r\n                    element.start,\r\n                    element.end,\r\n                    element.min,\r\n                    element.open,\r\n                    element.close,\r\n                    element.max,\r\n                    element.quantity\r\n                );\r\n                candle.exchange = element.exchange;\r\n                    candleList.push(candle);\r\n                $scope.lastCandle = candle;\r\n            });\r\n\r\n\r\n            //console.log(candleList);\r\n            $scope.candleChart = new CandleChart(candleList);\r\n\r\n            $scope.candleChart.addIndicator(\"MME\",indicatorService.MMEC,\"line\",{periods:9,color:\"green\"});\r\n            $scope.candleChart.addIndicator(\"MME\",indicatorService.MMEC,\"line\",{periods:21,color:\"red\"});\r\n            $scope.candleChart.addIndicator(\"bollinger\",indicatorService.bollinger,\"area\",{periods:20,color:\"grey\"});\r\n            //$scope.candleChart.addIndicator(\"bollinger\",indicatorService.bollinger,\"area\",{periods:10,color:\"pink\"});\r\n            $scope.candleChart.addIndicator(\"debugBollingerPart\",indicatorService.debugBollingerPart,\"line\",{periods:20,color:\"orange\"});\r\n            $scope.candleChart.addIndicator(\"debug_tops\",indicatorService.DEBUG_getTops,\"points\",{periods:0,color:\"green\",pointSize:3});\r\n            $scope.candleChart.addIndicator(\"debug_bottoms\",indicatorService.DEBUG_getBottoms,\"points\",{periods:0,color:\"red\",pointSize:3});\r\n\r\n            indicatorService.findTrenchs(candleList);\r\n            var resistencias = [];\r\n            var suportes = [];\r\n            indicatorService.trenchs.forEach(function(trench){\r\n\r\n               if(trench.value > candleList[candleList.length-1].close) {\r\n                   resistencias.push(trench);\r\n               }\r\n               else {\r\n                   suportes.push(trench);\r\n               }\r\n\r\n            });\r\n            resistencias = resistencias.sort(function(a,b){\r\n                return a.value - b.value;\r\n            });\r\n            suportes = suportes.sort(function(a,b){\r\n                return b.value - a.value;\r\n            });\r\n            while(resistencias.length > 2) resistencias.pop();\r\n            while(suportes.length > 2) suportes.pop();\r\n            suportes.forEach(function(trench){\r\n\r\n                 $scope.candleChart.addIndicator(\"trench\",indicatorService.drawLine,\"line\",{periods:trench.value,color:\"#107E28\"});\r\n\r\n            });\r\n            resistencias.forEach(function(trench){\r\n\r\n                $scope.candleChart.addIndicator(\"trench\",indicatorService.drawLine,\"line\",{periods:trench.value,color:\"#9C150F\"});\r\n\r\n            });\r\n            $scope.candleChart.update();\r\n\r\n\r\n\r\n            $scope.volumeChart = new VolumeChart(candleList);\r\n            $scope.volumeChart.addIndicator(\"volumeMMS\",indicatorService.volumeMMS,\"line\",{periods:21,color:\"red\"});\r\n            $scope.volumeChart.update();\r\n\r\n            var tempIfr = indicatorService.IFR(candleList,2);\r\n            var ifrData = [];\r\n            tempIfr.forEach(function(ifr){ifrData.push(ifr[0]); });\r\n            $scope.ifrChart = new LineChart(ifrData,\"#AEB404\");\r\n            $scope.volumeChart.addIndicator(\"IFR_LOW\",indicatorService.drawLine,\"line\",{periods:20,color:\"green\"});\r\n            $scope.volumeChart.addIndicator(\"IFR_HIGH\",indicatorService.drawLine,\"line\",{periods:80,color:\"red\"});\r\n            $scope.ifrChart.update();\r\n\r\n            var tempAD = indicatorService.accumDist(candleList);\r\n            var adData = [];\r\n            tempAD.forEach(function(ad){adData.push(ad[0]); });\r\n            $scope.adChart = new LineChart(adData,\"blue\");\r\n            $scope.adChart.update();\r\n\r\n            var tempBW = indicatorService.bollingerWidth(candleList,20);\r\n            var bwData = [];\r\n            tempBW.forEach(function(bw){bwData.push(bw[0]); });\r\n            $scope.bwChart = new LineChart(bwData,\"grey\");\r\n            $scope.bwChart.update();\r\n\r\n\r\n\r\n            $scope.candleList = candleList;\r\n\r\n\r\n            //$scope.detectOpportunity();\r\n\r\n\r\n\r\n\r\n            if(typeof selectDate !=='undefined') {\r\n\r\n                var index = data.data.findIndex(function(element){\r\n                    //console.log(element.timestamp === selectDate-3600,element.timestamp,selectDate-3600,selectDate);\r\n                    return element.timestamp === selectDate-3600;\r\n                });\r\n                selected = {\"row\": index, \"column\": 1};\r\n            }\r\n\r\n        },function(data){\r\n\r\n        });\r\n\r\n        var brickList = [];\r\n        url = \"stock/\"+$scope.stock.code+\"/renko/\"+$scope.renkoResolution;\r\n        $http.get(url).then(function(data){\r\n\r\n\r\n\r\n            data.data.forEach(function(element){\r\n                var candle = new Candle(\r\n                    element.e,\r\n                    element.s,\r\n                    Math.min(element.o,element.c),\r\n                    element.o,\r\n                    element.c,\r\n                    Math.max(element.o,element.c),\r\n                    0\r\n                );\r\n                //candle.exchange = element.exchange;\r\n                brickList.push(candle);\r\n                //$scope.lastCandle = candle;\r\n            });\r\n\r\n\r\n\r\n            $scope.renkoChart = new CandleChart(brickList);\r\n            $scope.renkoChart.update();\r\n\r\n\r\n        },function(data){});\r\n\r\n\r\n\r\n    };\r\n\r\n\r\n    $scope.detectOpportunity = function() {\r\n\r\n        if(opportunityService.detectOpportunity($scope.candleList,true)) {\r\n           var ifr = indicatorService.IFR($scope.candleList,2)[$scope.candleList.length-1][0];\r\n           console.log(opportunityService.setStopAndTarget($scope.candleList[$scope.candleList.length-1],ifr));\r\n        }\r\n\r\n    };\r\n\r\n    var wrappers = [];\r\n    var selected;\r\n    $scope.registerWrappers = function(chartWrapper,chart) {\r\n        //console.log(chart)\r\n\r\n        //console.log(chartWrapper,chart);\r\n        if(!wrappers.some(function(wrapper){\r\n                return wrapper.chart === chart;\r\n            })){\r\n            wrappers.push({\r\n                chart: chart,\r\n                wrapper: chartWrapper\r\n            })\r\n        }\r\n\r\n        $scope.selectHandler(selected);\r\n    };\r\n\r\n\r\n    $scope.selectHandler = function(selectedItem) {\r\n        //console.log(selectedItem);\r\n        selected = selectedItem;\r\n        if(typeof selectedItem === 'undefined') {\r\n            wrappers.forEach(function(wrapper){\r\n                wrapper.wrapper.getChart().setSelection([]);\r\n            });\r\n        }\r\n        else {\r\n            wrappers.forEach(function (wrapper) {\r\n                wrapper.wrapper.getChart().setSelection([selectedItem]);\r\n            });\r\n        }\r\n    };\r\n\r\n    console.info(\"candleController loaded\");\r\n\r\n\r\n    $scope.testeNovo = function() {\r\n        strategyTestService.bullOneTest($scope.stock.code,$scope.stock.periodLength,true);\r\n    }\r\n\r\n\r\n\r\n});","/**\r\n * Created by Ian on 28/12/2016.\r\n */\r\napp.controller(\"mainController\",function($scope,$http){\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    console.info(\"mainController Loaded\");\r\n});"]}